"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_MergeBranchesByFastForwardCommand = exports.se_ListTagsForResourceCommand = exports.se_ListRepositoriesForApprovalRuleTemplateCommand = exports.se_ListRepositoriesCommand = exports.se_ListPullRequestsCommand = exports.se_ListBranchesCommand = exports.se_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = exports.se_ListApprovalRuleTemplatesCommand = exports.se_GetRepositoryTriggersCommand = exports.se_GetRepositoryCommand = exports.se_GetPullRequestOverrideStateCommand = exports.se_GetPullRequestApprovalStatesCommand = exports.se_GetPullRequestCommand = exports.se_GetMergeOptionsCommand = exports.se_GetMergeConflictsCommand = exports.se_GetMergeCommitCommand = exports.se_GetFolderCommand = exports.se_GetFileCommand = exports.se_GetDifferencesCommand = exports.se_GetCommitCommand = exports.se_GetCommentsForPullRequestCommand = exports.se_GetCommentsForComparedCommitCommand = exports.se_GetCommentReactionsCommand = exports.se_GetCommentCommand = exports.se_GetBranchCommand = exports.se_GetBlobCommand = exports.se_GetApprovalRuleTemplateCommand = exports.se_EvaluatePullRequestApprovalRulesCommand = exports.se_DisassociateApprovalRuleTemplateFromRepositoryCommand = exports.se_DescribePullRequestEventsCommand = exports.se_DescribeMergeConflictsCommand = exports.se_DeleteRepositoryCommand = exports.se_DeletePullRequestApprovalRuleCommand = exports.se_DeleteFileCommand = exports.se_DeleteCommentContentCommand = exports.se_DeleteBranchCommand = exports.se_DeleteApprovalRuleTemplateCommand = exports.se_CreateUnreferencedMergeCommitCommand = exports.se_CreateRepositoryCommand = exports.se_CreatePullRequestApprovalRuleCommand = exports.se_CreatePullRequestCommand = exports.se_CreateCommitCommand = exports.se_CreateBranchCommand = exports.se_CreateApprovalRuleTemplateCommand = exports.se_BatchGetRepositoriesCommand = exports.se_BatchGetCommitsCommand = exports.se_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = exports.se_BatchDescribeMergeConflictsCommand = exports.se_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = exports.se_AssociateApprovalRuleTemplateWithRepositoryCommand = void 0;
exports.de_EvaluatePullRequestApprovalRulesCommand = exports.de_DisassociateApprovalRuleTemplateFromRepositoryCommand = exports.de_DescribePullRequestEventsCommand = exports.de_DescribeMergeConflictsCommand = exports.de_DeleteRepositoryCommand = exports.de_DeletePullRequestApprovalRuleCommand = exports.de_DeleteFileCommand = exports.de_DeleteCommentContentCommand = exports.de_DeleteBranchCommand = exports.de_DeleteApprovalRuleTemplateCommand = exports.de_CreateUnreferencedMergeCommitCommand = exports.de_CreateRepositoryCommand = exports.de_CreatePullRequestApprovalRuleCommand = exports.de_CreatePullRequestCommand = exports.de_CreateCommitCommand = exports.de_CreateBranchCommand = exports.de_CreateApprovalRuleTemplateCommand = exports.de_BatchGetRepositoriesCommand = exports.de_BatchGetCommitsCommand = exports.de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = exports.de_BatchDescribeMergeConflictsCommand = exports.de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = exports.de_AssociateApprovalRuleTemplateWithRepositoryCommand = exports.se_UpdateRepositoryNameCommand = exports.se_UpdateRepositoryDescriptionCommand = exports.se_UpdatePullRequestTitleCommand = exports.se_UpdatePullRequestStatusCommand = exports.se_UpdatePullRequestDescriptionCommand = exports.se_UpdatePullRequestApprovalStateCommand = exports.se_UpdatePullRequestApprovalRuleContentCommand = exports.se_UpdateDefaultBranchCommand = exports.se_UpdateCommentCommand = exports.se_UpdateApprovalRuleTemplateNameCommand = exports.se_UpdateApprovalRuleTemplateDescriptionCommand = exports.se_UpdateApprovalRuleTemplateContentCommand = exports.se_UntagResourceCommand = exports.se_TestRepositoryTriggersCommand = exports.se_TagResourceCommand = exports.se_PutRepositoryTriggersCommand = exports.se_PutFileCommand = exports.se_PutCommentReactionCommand = exports.se_PostCommentReplyCommand = exports.se_PostCommentForPullRequestCommand = exports.se_PostCommentForComparedCommitCommand = exports.se_OverridePullRequestApprovalRulesCommand = exports.se_MergePullRequestByThreeWayCommand = exports.se_MergePullRequestBySquashCommand = exports.se_MergePullRequestByFastForwardCommand = exports.se_MergeBranchesByThreeWayCommand = exports.se_MergeBranchesBySquashCommand = void 0;
exports.de_UpdatePullRequestDescriptionCommand = exports.de_UpdatePullRequestApprovalStateCommand = exports.de_UpdatePullRequestApprovalRuleContentCommand = exports.de_UpdateDefaultBranchCommand = exports.de_UpdateCommentCommand = exports.de_UpdateApprovalRuleTemplateNameCommand = exports.de_UpdateApprovalRuleTemplateDescriptionCommand = exports.de_UpdateApprovalRuleTemplateContentCommand = exports.de_UntagResourceCommand = exports.de_TestRepositoryTriggersCommand = exports.de_TagResourceCommand = exports.de_PutRepositoryTriggersCommand = exports.de_PutFileCommand = exports.de_PutCommentReactionCommand = exports.de_PostCommentReplyCommand = exports.de_PostCommentForPullRequestCommand = exports.de_PostCommentForComparedCommitCommand = exports.de_OverridePullRequestApprovalRulesCommand = exports.de_MergePullRequestByThreeWayCommand = exports.de_MergePullRequestBySquashCommand = exports.de_MergePullRequestByFastForwardCommand = exports.de_MergeBranchesByThreeWayCommand = exports.de_MergeBranchesBySquashCommand = exports.de_MergeBranchesByFastForwardCommand = exports.de_ListTagsForResourceCommand = exports.de_ListRepositoriesForApprovalRuleTemplateCommand = exports.de_ListRepositoriesCommand = exports.de_ListPullRequestsCommand = exports.de_ListBranchesCommand = exports.de_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = exports.de_ListApprovalRuleTemplatesCommand = exports.de_GetRepositoryTriggersCommand = exports.de_GetRepositoryCommand = exports.de_GetPullRequestOverrideStateCommand = exports.de_GetPullRequestApprovalStatesCommand = exports.de_GetPullRequestCommand = exports.de_GetMergeOptionsCommand = exports.de_GetMergeConflictsCommand = exports.de_GetMergeCommitCommand = exports.de_GetFolderCommand = exports.de_GetFileCommand = exports.de_GetDifferencesCommand = exports.de_GetCommitCommand = exports.de_GetCommentsForPullRequestCommand = exports.de_GetCommentsForComparedCommitCommand = exports.de_GetCommentReactionsCommand = exports.de_GetCommentCommand = exports.de_GetBranchCommand = exports.de_GetBlobCommand = exports.de_GetApprovalRuleTemplateCommand = void 0;
exports.de_UpdateRepositoryNameCommand = exports.de_UpdateRepositoryDescriptionCommand = exports.de_UpdatePullRequestTitleCommand = exports.de_UpdatePullRequestStatusCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const uuid_1 = require("uuid");
const CodeCommitServiceException_1 = require("../models/CodeCommitServiceException");
const models_0_1 = require("../models/models_0");
const models_1_1 = require("../models/models_1");
const se_AssociateApprovalRuleTemplateWithRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("AssociateApprovalRuleTemplateWithRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssociateApprovalRuleTemplateWithRepositoryCommand = se_AssociateApprovalRuleTemplateWithRepositoryCommand;
const se_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = async (input, context) => {
    const headers = sharedHeaders("BatchAssociateApprovalRuleTemplateWithRepositories");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = se_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand;
const se_BatchDescribeMergeConflictsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchDescribeMergeConflicts");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchDescribeMergeConflictsCommand = se_BatchDescribeMergeConflictsCommand;
const se_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = async (input, context) => {
    const headers = sharedHeaders("BatchDisassociateApprovalRuleTemplateFromRepositories");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = se_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand;
const se_BatchGetCommitsCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetCommits");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetCommitsCommand = se_BatchGetCommitsCommand;
const se_BatchGetRepositoriesCommand = async (input, context) => {
    const headers = sharedHeaders("BatchGetRepositories");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_BatchGetRepositoriesCommand = se_BatchGetRepositoriesCommand;
const se_CreateApprovalRuleTemplateCommand = async (input, context) => {
    const headers = sharedHeaders("CreateApprovalRuleTemplate");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateApprovalRuleTemplateCommand = se_CreateApprovalRuleTemplateCommand;
const se_CreateBranchCommand = async (input, context) => {
    const headers = sharedHeaders("CreateBranch");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateBranchCommand = se_CreateBranchCommand;
const se_CreateCommitCommand = async (input, context) => {
    const headers = sharedHeaders("CreateCommit");
    let body;
    body = JSON.stringify(se_CreateCommitInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateCommitCommand = se_CreateCommitCommand;
const se_CreatePullRequestCommand = async (input, context) => {
    const headers = sharedHeaders("CreatePullRequest");
    let body;
    body = JSON.stringify(se_CreatePullRequestInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreatePullRequestCommand = se_CreatePullRequestCommand;
const se_CreatePullRequestApprovalRuleCommand = async (input, context) => {
    const headers = sharedHeaders("CreatePullRequestApprovalRule");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreatePullRequestApprovalRuleCommand = se_CreatePullRequestApprovalRuleCommand;
const se_CreateRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("CreateRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateRepositoryCommand = se_CreateRepositoryCommand;
const se_CreateUnreferencedMergeCommitCommand = async (input, context) => {
    const headers = sharedHeaders("CreateUnreferencedMergeCommit");
    let body;
    body = JSON.stringify(se_CreateUnreferencedMergeCommitInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUnreferencedMergeCommitCommand = se_CreateUnreferencedMergeCommitCommand;
const se_DeleteApprovalRuleTemplateCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteApprovalRuleTemplate");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteApprovalRuleTemplateCommand = se_DeleteApprovalRuleTemplateCommand;
const se_DeleteBranchCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteBranch");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteBranchCommand = se_DeleteBranchCommand;
const se_DeleteCommentContentCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteCommentContent");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteCommentContentCommand = se_DeleteCommentContentCommand;
const se_DeleteFileCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteFile");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteFileCommand = se_DeleteFileCommand;
const se_DeletePullRequestApprovalRuleCommand = async (input, context) => {
    const headers = sharedHeaders("DeletePullRequestApprovalRule");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeletePullRequestApprovalRuleCommand = se_DeletePullRequestApprovalRuleCommand;
const se_DeleteRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteRepositoryCommand = se_DeleteRepositoryCommand;
const se_DescribeMergeConflictsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeMergeConflicts");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeMergeConflictsCommand = se_DescribeMergeConflictsCommand;
const se_DescribePullRequestEventsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribePullRequestEvents");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribePullRequestEventsCommand = se_DescribePullRequestEventsCommand;
const se_DisassociateApprovalRuleTemplateFromRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("DisassociateApprovalRuleTemplateFromRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DisassociateApprovalRuleTemplateFromRepositoryCommand = se_DisassociateApprovalRuleTemplateFromRepositoryCommand;
const se_EvaluatePullRequestApprovalRulesCommand = async (input, context) => {
    const headers = sharedHeaders("EvaluatePullRequestApprovalRules");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_EvaluatePullRequestApprovalRulesCommand = se_EvaluatePullRequestApprovalRulesCommand;
const se_GetApprovalRuleTemplateCommand = async (input, context) => {
    const headers = sharedHeaders("GetApprovalRuleTemplate");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetApprovalRuleTemplateCommand = se_GetApprovalRuleTemplateCommand;
const se_GetBlobCommand = async (input, context) => {
    const headers = sharedHeaders("GetBlob");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetBlobCommand = se_GetBlobCommand;
const se_GetBranchCommand = async (input, context) => {
    const headers = sharedHeaders("GetBranch");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetBranchCommand = se_GetBranchCommand;
const se_GetCommentCommand = async (input, context) => {
    const headers = sharedHeaders("GetComment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCommentCommand = se_GetCommentCommand;
const se_GetCommentReactionsCommand = async (input, context) => {
    const headers = sharedHeaders("GetCommentReactions");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCommentReactionsCommand = se_GetCommentReactionsCommand;
const se_GetCommentsForComparedCommitCommand = async (input, context) => {
    const headers = sharedHeaders("GetCommentsForComparedCommit");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCommentsForComparedCommitCommand = se_GetCommentsForComparedCommitCommand;
const se_GetCommentsForPullRequestCommand = async (input, context) => {
    const headers = sharedHeaders("GetCommentsForPullRequest");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCommentsForPullRequestCommand = se_GetCommentsForPullRequestCommand;
const se_GetCommitCommand = async (input, context) => {
    const headers = sharedHeaders("GetCommit");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCommitCommand = se_GetCommitCommand;
const se_GetDifferencesCommand = async (input, context) => {
    const headers = sharedHeaders("GetDifferences");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDifferencesCommand = se_GetDifferencesCommand;
const se_GetFileCommand = async (input, context) => {
    const headers = sharedHeaders("GetFile");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetFileCommand = se_GetFileCommand;
const se_GetFolderCommand = async (input, context) => {
    const headers = sharedHeaders("GetFolder");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetFolderCommand = se_GetFolderCommand;
const se_GetMergeCommitCommand = async (input, context) => {
    const headers = sharedHeaders("GetMergeCommit");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetMergeCommitCommand = se_GetMergeCommitCommand;
const se_GetMergeConflictsCommand = async (input, context) => {
    const headers = sharedHeaders("GetMergeConflicts");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetMergeConflictsCommand = se_GetMergeConflictsCommand;
const se_GetMergeOptionsCommand = async (input, context) => {
    const headers = sharedHeaders("GetMergeOptions");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetMergeOptionsCommand = se_GetMergeOptionsCommand;
const se_GetPullRequestCommand = async (input, context) => {
    const headers = sharedHeaders("GetPullRequest");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPullRequestCommand = se_GetPullRequestCommand;
const se_GetPullRequestApprovalStatesCommand = async (input, context) => {
    const headers = sharedHeaders("GetPullRequestApprovalStates");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPullRequestApprovalStatesCommand = se_GetPullRequestApprovalStatesCommand;
const se_GetPullRequestOverrideStateCommand = async (input, context) => {
    const headers = sharedHeaders("GetPullRequestOverrideState");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetPullRequestOverrideStateCommand = se_GetPullRequestOverrideStateCommand;
const se_GetRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("GetRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetRepositoryCommand = se_GetRepositoryCommand;
const se_GetRepositoryTriggersCommand = async (input, context) => {
    const headers = sharedHeaders("GetRepositoryTriggers");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetRepositoryTriggersCommand = se_GetRepositoryTriggersCommand;
const se_ListApprovalRuleTemplatesCommand = async (input, context) => {
    const headers = sharedHeaders("ListApprovalRuleTemplates");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListApprovalRuleTemplatesCommand = se_ListApprovalRuleTemplatesCommand;
const se_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("ListAssociatedApprovalRuleTemplatesForRepository");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = se_ListAssociatedApprovalRuleTemplatesForRepositoryCommand;
const se_ListBranchesCommand = async (input, context) => {
    const headers = sharedHeaders("ListBranches");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListBranchesCommand = se_ListBranchesCommand;
const se_ListPullRequestsCommand = async (input, context) => {
    const headers = sharedHeaders("ListPullRequests");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListPullRequestsCommand = se_ListPullRequestsCommand;
const se_ListRepositoriesCommand = async (input, context) => {
    const headers = sharedHeaders("ListRepositories");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRepositoriesCommand = se_ListRepositoriesCommand;
const se_ListRepositoriesForApprovalRuleTemplateCommand = async (input, context) => {
    const headers = sharedHeaders("ListRepositoriesForApprovalRuleTemplate");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListRepositoriesForApprovalRuleTemplateCommand = se_ListRepositoriesForApprovalRuleTemplateCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_MergeBranchesByFastForwardCommand = async (input, context) => {
    const headers = sharedHeaders("MergeBranchesByFastForward");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergeBranchesByFastForwardCommand = se_MergeBranchesByFastForwardCommand;
const se_MergeBranchesBySquashCommand = async (input, context) => {
    const headers = sharedHeaders("MergeBranchesBySquash");
    let body;
    body = JSON.stringify(se_MergeBranchesBySquashInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergeBranchesBySquashCommand = se_MergeBranchesBySquashCommand;
const se_MergeBranchesByThreeWayCommand = async (input, context) => {
    const headers = sharedHeaders("MergeBranchesByThreeWay");
    let body;
    body = JSON.stringify(se_MergeBranchesByThreeWayInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergeBranchesByThreeWayCommand = se_MergeBranchesByThreeWayCommand;
const se_MergePullRequestByFastForwardCommand = async (input, context) => {
    const headers = sharedHeaders("MergePullRequestByFastForward");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergePullRequestByFastForwardCommand = se_MergePullRequestByFastForwardCommand;
const se_MergePullRequestBySquashCommand = async (input, context) => {
    const headers = sharedHeaders("MergePullRequestBySquash");
    let body;
    body = JSON.stringify(se_MergePullRequestBySquashInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergePullRequestBySquashCommand = se_MergePullRequestBySquashCommand;
const se_MergePullRequestByThreeWayCommand = async (input, context) => {
    const headers = sharedHeaders("MergePullRequestByThreeWay");
    let body;
    body = JSON.stringify(se_MergePullRequestByThreeWayInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_MergePullRequestByThreeWayCommand = se_MergePullRequestByThreeWayCommand;
const se_OverridePullRequestApprovalRulesCommand = async (input, context) => {
    const headers = sharedHeaders("OverridePullRequestApprovalRules");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_OverridePullRequestApprovalRulesCommand = se_OverridePullRequestApprovalRulesCommand;
const se_PostCommentForComparedCommitCommand = async (input, context) => {
    const headers = sharedHeaders("PostCommentForComparedCommit");
    let body;
    body = JSON.stringify(se_PostCommentForComparedCommitInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PostCommentForComparedCommitCommand = se_PostCommentForComparedCommitCommand;
const se_PostCommentForPullRequestCommand = async (input, context) => {
    const headers = sharedHeaders("PostCommentForPullRequest");
    let body;
    body = JSON.stringify(se_PostCommentForPullRequestInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PostCommentForPullRequestCommand = se_PostCommentForPullRequestCommand;
const se_PostCommentReplyCommand = async (input, context) => {
    const headers = sharedHeaders("PostCommentReply");
    let body;
    body = JSON.stringify(se_PostCommentReplyInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PostCommentReplyCommand = se_PostCommentReplyCommand;
const se_PutCommentReactionCommand = async (input, context) => {
    const headers = sharedHeaders("PutCommentReaction");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutCommentReactionCommand = se_PutCommentReactionCommand;
const se_PutFileCommand = async (input, context) => {
    const headers = sharedHeaders("PutFile");
    let body;
    body = JSON.stringify(se_PutFileInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutFileCommand = se_PutFileCommand;
const se_PutRepositoryTriggersCommand = async (input, context) => {
    const headers = sharedHeaders("PutRepositoryTriggers");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_PutRepositoryTriggersCommand = se_PutRepositoryTriggersCommand;
const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TestRepositoryTriggersCommand = async (input, context) => {
    const headers = sharedHeaders("TestRepositoryTriggers");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TestRepositoryTriggersCommand = se_TestRepositoryTriggersCommand;
const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateApprovalRuleTemplateContentCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateApprovalRuleTemplateContent");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateApprovalRuleTemplateContentCommand = se_UpdateApprovalRuleTemplateContentCommand;
const se_UpdateApprovalRuleTemplateDescriptionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateApprovalRuleTemplateDescription");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateApprovalRuleTemplateDescriptionCommand = se_UpdateApprovalRuleTemplateDescriptionCommand;
const se_UpdateApprovalRuleTemplateNameCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateApprovalRuleTemplateName");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateApprovalRuleTemplateNameCommand = se_UpdateApprovalRuleTemplateNameCommand;
const se_UpdateCommentCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateComment");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateCommentCommand = se_UpdateCommentCommand;
const se_UpdateDefaultBranchCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateDefaultBranch");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateDefaultBranchCommand = se_UpdateDefaultBranchCommand;
const se_UpdatePullRequestApprovalRuleContentCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePullRequestApprovalRuleContent");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePullRequestApprovalRuleContentCommand = se_UpdatePullRequestApprovalRuleContentCommand;
const se_UpdatePullRequestApprovalStateCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePullRequestApprovalState");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePullRequestApprovalStateCommand = se_UpdatePullRequestApprovalStateCommand;
const se_UpdatePullRequestDescriptionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePullRequestDescription");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePullRequestDescriptionCommand = se_UpdatePullRequestDescriptionCommand;
const se_UpdatePullRequestStatusCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePullRequestStatus");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePullRequestStatusCommand = se_UpdatePullRequestStatusCommand;
const se_UpdatePullRequestTitleCommand = async (input, context) => {
    const headers = sharedHeaders("UpdatePullRequestTitle");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdatePullRequestTitleCommand = se_UpdatePullRequestTitleCommand;
const se_UpdateRepositoryDescriptionCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateRepositoryDescription");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateRepositoryDescriptionCommand = se_UpdateRepositoryDescriptionCommand;
const se_UpdateRepositoryNameCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateRepositoryName");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateRepositoryNameCommand = se_UpdateRepositoryNameCommand;
const de_AssociateApprovalRuleTemplateWithRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssociateApprovalRuleTemplateWithRepositoryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_AssociateApprovalRuleTemplateWithRepositoryCommand = de_AssociateApprovalRuleTemplateWithRepositoryCommand;
const de_AssociateApprovalRuleTemplateWithRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumRuleTemplatesAssociatedWithRepositoryException":
        case "com.amazonaws.codecommit#MaximumRuleTemplatesAssociatedWithRepositoryException":
            throw await de_MaximumRuleTemplatesAssociatedWithRepositoryExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand = de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommand;
const de_BatchAssociateApprovalRuleTemplateWithRepositoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "MaximumRepositoryNamesExceededException":
        case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
            throw await de_MaximumRepositoryNamesExceededExceptionRes(parsedOutput, context);
        case "RepositoryNamesRequiredException":
        case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
            throw await de_RepositoryNamesRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchDescribeMergeConflictsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchDescribeMergeConflictsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchDescribeMergeConflictsCommand = de_BatchDescribeMergeConflictsCommand;
const de_BatchDescribeMergeConflictsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxConflictFilesException":
        case "com.amazonaws.codecommit#InvalidMaxConflictFilesException":
            throw await de_InvalidMaxConflictFilesExceptionRes(parsedOutput, context);
        case "InvalidMaxMergeHunksException":
        case "com.amazonaws.codecommit#InvalidMaxMergeHunksException":
            throw await de_InvalidMaxMergeHunksExceptionRes(parsedOutput, context);
        case "InvalidMergeOptionException":
        case "com.amazonaws.codecommit#InvalidMergeOptionException":
            throw await de_InvalidMergeOptionExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MergeOptionRequiredException":
        case "com.amazonaws.codecommit#MergeOptionRequiredException":
            throw await de_MergeOptionRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand = de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommand;
const de_BatchDisassociateApprovalRuleTemplateFromRepositoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "MaximumRepositoryNamesExceededException":
        case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
            throw await de_MaximumRepositoryNamesExceededExceptionRes(parsedOutput, context);
        case "RepositoryNamesRequiredException":
        case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
            throw await de_RepositoryNamesRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetCommitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetCommitsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetCommitsCommand = de_BatchGetCommitsCommand;
const de_BatchGetCommitsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitIdsLimitExceededException":
        case "com.amazonaws.codecommit#CommitIdsLimitExceededException":
            throw await de_CommitIdsLimitExceededExceptionRes(parsedOutput, context);
        case "CommitIdsListRequiredException":
        case "com.amazonaws.codecommit#CommitIdsListRequiredException":
            throw await de_CommitIdsListRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_BatchGetRepositoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchGetRepositoriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchGetRepositoriesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_BatchGetRepositoriesCommand = de_BatchGetRepositoriesCommand;
const de_BatchGetRepositoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumRepositoryNamesExceededException":
        case "com.amazonaws.codecommit#MaximumRepositoryNamesExceededException":
            throw await de_MaximumRepositoryNamesExceededExceptionRes(parsedOutput, context);
        case "RepositoryNamesRequiredException":
        case "com.amazonaws.codecommit#RepositoryNamesRequiredException":
            throw await de_RepositoryNamesRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateApprovalRuleTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateApprovalRuleTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateApprovalRuleTemplateOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateApprovalRuleTemplateCommand = de_CreateApprovalRuleTemplateCommand;
const de_CreateApprovalRuleTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateContentRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateContentRequiredException":
            throw await de_ApprovalRuleTemplateContentRequiredExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameAlreadyExistsException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameAlreadyExistsException":
            throw await de_ApprovalRuleTemplateNameAlreadyExistsExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateContentException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateContentException":
            throw await de_InvalidApprovalRuleTemplateContentExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateDescriptionException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateDescriptionException":
            throw await de_InvalidApprovalRuleTemplateDescriptionExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "NumberOfRuleTemplatesExceededException":
        case "com.amazonaws.codecommit#NumberOfRuleTemplatesExceededException":
            throw await de_NumberOfRuleTemplatesExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateBranchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateBranchCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_CreateBranchCommand = de_CreateBranchCommand;
const de_CreateBranchCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchNameExistsException":
        case "com.amazonaws.codecommit#BranchNameExistsException":
            throw await de_BranchNameExistsExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateCommitCommand = de_CreateCommitCommand;
const de_CreateCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "DirectoryNameConflictsWithFileNameException":
        case "com.amazonaws.codecommit#DirectoryNameConflictsWithFileNameException":
            throw await de_DirectoryNameConflictsWithFileNameExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentAndSourceFileSpecifiedException":
        case "com.amazonaws.codecommit#FileContentAndSourceFileSpecifiedException":
            throw await de_FileContentAndSourceFileSpecifiedExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FileDoesNotExistException":
        case "com.amazonaws.codecommit#FileDoesNotExistException":
            throw await de_FileDoesNotExistExceptionRes(parsedOutput, context);
        case "FileEntryRequiredException":
        case "com.amazonaws.codecommit#FileEntryRequiredException":
            throw await de_FileEntryRequiredExceptionRes(parsedOutput, context);
        case "FileModeRequiredException":
        case "com.amazonaws.codecommit#FileModeRequiredException":
            throw await de_FileModeRequiredExceptionRes(parsedOutput, context);
        case "FileNameConflictsWithDirectoryNameException":
        case "com.amazonaws.codecommit#FileNameConflictsWithDirectoryNameException":
            throw await de_FileNameConflictsWithDirectoryNameExceptionRes(parsedOutput, context);
        case "FilePathConflictsWithSubmodulePathException":
        case "com.amazonaws.codecommit#FilePathConflictsWithSubmodulePathException":
            throw await de_FilePathConflictsWithSubmodulePathExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidDeletionParameterException":
        case "com.amazonaws.codecommit#InvalidDeletionParameterException":
            throw await de_InvalidDeletionParameterExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidParentCommitIdException":
        case "com.amazonaws.codecommit#InvalidParentCommitIdException":
            throw await de_InvalidParentCommitIdExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumFileEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumFileEntriesExceededException":
            throw await de_MaximumFileEntriesExceededExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "NoChangeException":
        case "com.amazonaws.codecommit#NoChangeException":
            throw await de_NoChangeExceptionRes(parsedOutput, context);
        case "ParentCommitDoesNotExistException":
        case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
            throw await de_ParentCommitDoesNotExistExceptionRes(parsedOutput, context);
        case "ParentCommitIdOutdatedException":
        case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
            throw await de_ParentCommitIdOutdatedExceptionRes(parsedOutput, context);
        case "ParentCommitIdRequiredException":
        case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
            throw await de_ParentCommitIdRequiredExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "PutFileEntryConflictException":
        case "com.amazonaws.codecommit#PutFileEntryConflictException":
            throw await de_PutFileEntryConflictExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RestrictedSourceFileException":
        case "com.amazonaws.codecommit#RestrictedSourceFileException":
            throw await de_RestrictedSourceFileExceptionRes(parsedOutput, context);
        case "SamePathRequestException":
        case "com.amazonaws.codecommit#SamePathRequestException":
            throw await de_SamePathRequestExceptionRes(parsedOutput, context);
        case "SourceFileOrContentRequiredException":
        case "com.amazonaws.codecommit#SourceFileOrContentRequiredException":
            throw await de_SourceFileOrContentRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePullRequestCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePullRequestCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePullRequestOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreatePullRequestCommand = de_CreatePullRequestCommand;
const de_CreatePullRequestCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientRequestTokenRequiredException":
        case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
            throw await de_ClientRequestTokenRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "IdempotencyParameterMismatchException":
        case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
            throw await de_IdempotencyParameterMismatchExceptionRes(parsedOutput, context);
        case "InvalidClientRequestTokenException":
        case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
            throw await de_InvalidClientRequestTokenExceptionRes(parsedOutput, context);
        case "InvalidDescriptionException":
        case "com.amazonaws.codecommit#InvalidDescriptionException":
            throw await de_InvalidDescriptionExceptionRes(parsedOutput, context);
        case "InvalidReferenceNameException":
        case "com.amazonaws.codecommit#InvalidReferenceNameException":
            throw await de_InvalidReferenceNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidTargetException":
        case "com.amazonaws.codecommit#InvalidTargetException":
            throw await de_InvalidTargetExceptionRes(parsedOutput, context);
        case "InvalidTargetsException":
        case "com.amazonaws.codecommit#InvalidTargetsException":
            throw await de_InvalidTargetsExceptionRes(parsedOutput, context);
        case "InvalidTitleException":
        case "com.amazonaws.codecommit#InvalidTitleException":
            throw await de_InvalidTitleExceptionRes(parsedOutput, context);
        case "MaximumOpenPullRequestsExceededException":
        case "com.amazonaws.codecommit#MaximumOpenPullRequestsExceededException":
            throw await de_MaximumOpenPullRequestsExceededExceptionRes(parsedOutput, context);
        case "MultipleRepositoriesInPullRequestException":
        case "com.amazonaws.codecommit#MultipleRepositoriesInPullRequestException":
            throw await de_MultipleRepositoriesInPullRequestExceptionRes(parsedOutput, context);
        case "ReferenceDoesNotExistException":
        case "com.amazonaws.codecommit#ReferenceDoesNotExistException":
            throw await de_ReferenceDoesNotExistExceptionRes(parsedOutput, context);
        case "ReferenceNameRequiredException":
        case "com.amazonaws.codecommit#ReferenceNameRequiredException":
            throw await de_ReferenceNameRequiredExceptionRes(parsedOutput, context);
        case "ReferenceTypeNotSupportedException":
        case "com.amazonaws.codecommit#ReferenceTypeNotSupportedException":
            throw await de_ReferenceTypeNotSupportedExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "SourceAndDestinationAreSameException":
        case "com.amazonaws.codecommit#SourceAndDestinationAreSameException":
            throw await de_SourceAndDestinationAreSameExceptionRes(parsedOutput, context);
        case "TargetRequiredException":
        case "com.amazonaws.codecommit#TargetRequiredException":
            throw await de_TargetRequiredExceptionRes(parsedOutput, context);
        case "TargetsRequiredException":
        case "com.amazonaws.codecommit#TargetsRequiredException":
            throw await de_TargetsRequiredExceptionRes(parsedOutput, context);
        case "TitleRequiredException":
        case "com.amazonaws.codecommit#TitleRequiredException":
            throw await de_TitleRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePullRequestApprovalRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePullRequestApprovalRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePullRequestApprovalRuleOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreatePullRequestApprovalRuleCommand = de_CreatePullRequestApprovalRuleCommand;
const de_CreatePullRequestApprovalRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleContentRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleContentRequiredException":
            throw await de_ApprovalRuleContentRequiredExceptionRes(parsedOutput, context);
        case "ApprovalRuleNameAlreadyExistsException":
        case "com.amazonaws.codecommit#ApprovalRuleNameAlreadyExistsException":
            throw await de_ApprovalRuleNameAlreadyExistsExceptionRes(parsedOutput, context);
        case "ApprovalRuleNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
            throw await de_ApprovalRuleNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleContentException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleContentException":
            throw await de_InvalidApprovalRuleContentExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
            throw await de_InvalidApprovalRuleNameExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "NumberOfRulesExceededException":
        case "com.amazonaws.codecommit#NumberOfRulesExceededException":
            throw await de_NumberOfRulesExceededExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateRepositoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRepositoryOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateRepositoryCommand = de_CreateRepositoryCommand;
const de_CreateRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryDescriptionException":
        case "com.amazonaws.codecommit#InvalidRepositoryDescriptionException":
            throw await de_InvalidRepositoryDescriptionExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidSystemTagUsageException":
        case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
            throw await de_InvalidSystemTagUsageExceptionRes(parsedOutput, context);
        case "InvalidTagsMapException":
        case "com.amazonaws.codecommit#InvalidTagsMapException":
            throw await de_InvalidTagsMapExceptionRes(parsedOutput, context);
        case "RepositoryLimitExceededException":
        case "com.amazonaws.codecommit#RepositoryLimitExceededException":
            throw await de_RepositoryLimitExceededExceptionRes(parsedOutput, context);
        case "RepositoryNameExistsException":
        case "com.amazonaws.codecommit#RepositoryNameExistsException":
            throw await de_RepositoryNameExistsExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TagPolicyException":
        case "com.amazonaws.codecommit#TagPolicyException":
            throw await de_TagPolicyExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.codecommit#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateUnreferencedMergeCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateUnreferencedMergeCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateUnreferencedMergeCommitCommand = de_CreateUnreferencedMergeCommitCommand;
const de_CreateUnreferencedMergeCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FileModeRequiredException":
        case "com.amazonaws.codecommit#FileModeRequiredException":
            throw await de_FileModeRequiredExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionException":
            throw await de_InvalidConflictResolutionExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidMergeOptionException":
        case "com.amazonaws.codecommit#InvalidMergeOptionException":
            throw await de_InvalidMergeOptionExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidReplacementContentException":
        case "com.amazonaws.codecommit#InvalidReplacementContentException":
            throw await de_InvalidReplacementContentExceptionRes(parsedOutput, context);
        case "InvalidReplacementTypeException":
        case "com.amazonaws.codecommit#InvalidReplacementTypeException":
            throw await de_InvalidReplacementTypeExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "MaximumConflictResolutionEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
            throw await de_MaximumConflictResolutionEntriesExceededExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MergeOptionRequiredException":
        case "com.amazonaws.codecommit#MergeOptionRequiredException":
            throw await de_MergeOptionRequiredExceptionRes(parsedOutput, context);
        case "MultipleConflictResolutionEntriesException":
        case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
            throw await de_MultipleConflictResolutionEntriesExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "ReplacementContentRequiredException":
        case "com.amazonaws.codecommit#ReplacementContentRequiredException":
            throw await de_ReplacementContentRequiredExceptionRes(parsedOutput, context);
        case "ReplacementTypeRequiredException":
        case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
            throw await de_ReplacementTypeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteApprovalRuleTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteApprovalRuleTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteApprovalRuleTemplateCommand = de_DeleteApprovalRuleTemplateCommand;
const de_DeleteApprovalRuleTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateInUseException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateInUseException":
            throw await de_ApprovalRuleTemplateInUseExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteBranchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteBranchCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteBranchCommand = de_DeleteBranchCommand;
const de_DeleteBranchCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "DefaultBranchCannotBeDeletedException":
        case "com.amazonaws.codecommit#DefaultBranchCannotBeDeletedException":
            throw await de_DefaultBranchCannotBeDeletedExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCommentContentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteCommentContentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteCommentContentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteCommentContentCommand = de_DeleteCommentContentCommand;
const de_DeleteCommentContentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommentDeletedException":
        case "com.amazonaws.codecommit#CommentDeletedException":
            throw await de_CommentDeletedExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteFileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteFileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteFileCommand = de_DeleteFileCommand;
const de_DeleteFileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileDoesNotExistException":
        case "com.amazonaws.codecommit#FileDoesNotExistException":
            throw await de_FileDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidParentCommitIdException":
        case "com.amazonaws.codecommit#InvalidParentCommitIdException":
            throw await de_InvalidParentCommitIdExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "ParentCommitDoesNotExistException":
        case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
            throw await de_ParentCommitDoesNotExistExceptionRes(parsedOutput, context);
        case "ParentCommitIdOutdatedException":
        case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
            throw await de_ParentCommitIdOutdatedExceptionRes(parsedOutput, context);
        case "ParentCommitIdRequiredException":
        case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
            throw await de_ParentCommitIdRequiredExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeletePullRequestApprovalRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePullRequestApprovalRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeletePullRequestApprovalRuleCommand = de_DeletePullRequestApprovalRuleCommand;
const de_DeletePullRequestApprovalRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
            throw await de_ApprovalRuleNameRequiredExceptionRes(parsedOutput, context);
        case "CannotDeleteApprovalRuleFromTemplateException":
        case "com.amazonaws.codecommit#CannotDeleteApprovalRuleFromTemplateException":
            throw await de_CannotDeleteApprovalRuleFromTemplateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
            throw await de_InvalidApprovalRuleNameExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRepositoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteRepositoryCommand = de_DeleteRepositoryCommand;
const de_DeleteRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeMergeConflictsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMergeConflictsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeMergeConflictsCommand = de_DescribeMergeConflictsCommand;
const de_DescribeMergeConflictsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileDoesNotExistException":
        case "com.amazonaws.codecommit#FileDoesNotExistException":
            throw await de_FileDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxMergeHunksException":
        case "com.amazonaws.codecommit#InvalidMaxMergeHunksException":
            throw await de_InvalidMaxMergeHunksExceptionRes(parsedOutput, context);
        case "InvalidMergeOptionException":
        case "com.amazonaws.codecommit#InvalidMergeOptionException":
            throw await de_InvalidMergeOptionExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MergeOptionRequiredException":
        case "com.amazonaws.codecommit#MergeOptionRequiredException":
            throw await de_MergeOptionRequiredExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribePullRequestEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePullRequestEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePullRequestEventsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribePullRequestEventsCommand = de_DescribePullRequestEventsCommand;
const de_DescribePullRequestEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ActorDoesNotExistException":
        case "com.amazonaws.codecommit#ActorDoesNotExistException":
            throw await de_ActorDoesNotExistExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidActorArnException":
        case "com.amazonaws.codecommit#InvalidActorArnException":
            throw await de_InvalidActorArnExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidPullRequestEventTypeException":
        case "com.amazonaws.codecommit#InvalidPullRequestEventTypeException":
            throw await de_InvalidPullRequestEventTypeExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisassociateApprovalRuleTemplateFromRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisassociateApprovalRuleTemplateFromRepositoryCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_DisassociateApprovalRuleTemplateFromRepositoryCommand = de_DisassociateApprovalRuleTemplateFromRepositoryCommand;
const de_DisassociateApprovalRuleTemplateFromRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EvaluatePullRequestApprovalRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EvaluatePullRequestApprovalRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_EvaluatePullRequestApprovalRulesCommand = de_EvaluatePullRequestApprovalRulesCommand;
const de_EvaluatePullRequestApprovalRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRevisionIdException":
        case "com.amazonaws.codecommit#InvalidRevisionIdException":
            throw await de_InvalidRevisionIdExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionIdRequiredException":
        case "com.amazonaws.codecommit#RevisionIdRequiredException":
            throw await de_RevisionIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionNotCurrentException":
        case "com.amazonaws.codecommit#RevisionNotCurrentException":
            throw await de_RevisionNotCurrentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetApprovalRuleTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetApprovalRuleTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetApprovalRuleTemplateOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetApprovalRuleTemplateCommand = de_GetApprovalRuleTemplateCommand;
const de_GetApprovalRuleTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBlobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetBlobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetBlobOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetBlobCommand = de_GetBlobCommand;
const de_GetBlobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BlobIdDoesNotExistException":
        case "com.amazonaws.codecommit#BlobIdDoesNotExistException":
            throw await de_BlobIdDoesNotExistExceptionRes(parsedOutput, context);
        case "BlobIdRequiredException":
        case "com.amazonaws.codecommit#BlobIdRequiredException":
            throw await de_BlobIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileTooLargeException":
        case "com.amazonaws.codecommit#FileTooLargeException":
            throw await de_FileTooLargeExceptionRes(parsedOutput, context);
        case "InvalidBlobIdException":
        case "com.amazonaws.codecommit#InvalidBlobIdException":
            throw await de_InvalidBlobIdExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBranchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetBranchCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetBranchCommand = de_GetBranchCommand;
const de_GetBranchCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCommentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCommentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCommentCommand = de_GetCommentCommand;
const de_GetCommentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommentDeletedException":
        case "com.amazonaws.codecommit#CommentDeletedException":
            throw await de_CommentDeletedExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCommentReactionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommentReactionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCommentReactionsCommand = de_GetCommentReactionsCommand;
const de_GetCommentReactionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommentDeletedException":
        case "com.amazonaws.codecommit#CommentDeletedException":
            throw await de_CommentDeletedExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidReactionUserArnException":
        case "com.amazonaws.codecommit#InvalidReactionUserArnException":
            throw await de_InvalidReactionUserArnExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCommentsForComparedCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommentsForComparedCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCommentsForComparedCommitOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCommentsForComparedCommitCommand = de_GetCommentsForComparedCommitCommand;
const de_GetCommentsForComparedCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCommentsForPullRequestCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommentsForPullRequestCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCommentsForPullRequestOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCommentsForPullRequestCommand = de_GetCommentsForPullRequestCommand;
const de_GetCommentsForPullRequestCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryNotAssociatedWithPullRequestException":
        case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
            throw await de_RepositoryNotAssociatedWithPullRequestExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCommitCommand = de_GetCommitCommand;
const de_GetCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitIdDoesNotExistException":
        case "com.amazonaws.codecommit#CommitIdDoesNotExistException":
            throw await de_CommitIdDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetDifferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDifferencesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetDifferencesCommand = de_GetDifferencesCommand;
const de_GetDifferencesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PathDoesNotExistException":
        case "com.amazonaws.codecommit#PathDoesNotExistException":
            throw await de_PathDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetFileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetFileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFileOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetFileCommand = de_GetFileCommand;
const de_GetFileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileDoesNotExistException":
        case "com.amazonaws.codecommit#FileDoesNotExistException":
            throw await de_FileDoesNotExistExceptionRes(parsedOutput, context);
        case "FileTooLargeException":
        case "com.amazonaws.codecommit#FileTooLargeException":
            throw await de_FileTooLargeExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetFolderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetFolderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetFolderCommand = de_GetFolderCommand;
const de_GetFolderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FolderDoesNotExistException":
        case "com.amazonaws.codecommit#FolderDoesNotExistException":
            throw await de_FolderDoesNotExistExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMergeCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMergeCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetMergeCommitCommand = de_GetMergeCommitCommand;
const de_GetMergeCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMergeConflictsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMergeConflictsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetMergeConflictsCommand = de_GetMergeConflictsCommand;
const de_GetMergeConflictsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidDestinationCommitSpecifierException":
        case "com.amazonaws.codecommit#InvalidDestinationCommitSpecifierException":
            throw await de_InvalidDestinationCommitSpecifierExceptionRes(parsedOutput, context);
        case "InvalidMaxConflictFilesException":
        case "com.amazonaws.codecommit#InvalidMaxConflictFilesException":
            throw await de_InvalidMaxConflictFilesExceptionRes(parsedOutput, context);
        case "InvalidMergeOptionException":
        case "com.amazonaws.codecommit#InvalidMergeOptionException":
            throw await de_InvalidMergeOptionExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidSourceCommitSpecifierException":
        case "com.amazonaws.codecommit#InvalidSourceCommitSpecifierException":
            throw await de_InvalidSourceCommitSpecifierExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MergeOptionRequiredException":
        case "com.amazonaws.codecommit#MergeOptionRequiredException":
            throw await de_MergeOptionRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetMergeOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMergeOptionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetMergeOptionsCommand = de_GetMergeOptionsCommand;
const de_GetMergeOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPullRequestCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPullRequestCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPullRequestOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPullRequestCommand = de_GetPullRequestCommand;
const de_GetPullRequestCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPullRequestApprovalStatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPullRequestApprovalStatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPullRequestApprovalStatesCommand = de_GetPullRequestApprovalStatesCommand;
const de_GetPullRequestApprovalStatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRevisionIdException":
        case "com.amazonaws.codecommit#InvalidRevisionIdException":
            throw await de_InvalidRevisionIdExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionIdRequiredException":
        case "com.amazonaws.codecommit#RevisionIdRequiredException":
            throw await de_RevisionIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPullRequestOverrideStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPullRequestOverrideStateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetPullRequestOverrideStateCommand = de_GetPullRequestOverrideStateCommand;
const de_GetPullRequestOverrideStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRevisionIdException":
        case "com.amazonaws.codecommit#InvalidRevisionIdException":
            throw await de_InvalidRevisionIdExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionIdRequiredException":
        case "com.amazonaws.codecommit#RevisionIdRequiredException":
            throw await de_RevisionIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRepositoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRepositoryOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetRepositoryCommand = de_GetRepositoryCommand;
const de_GetRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRepositoryTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRepositoryTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetRepositoryTriggersCommand = de_GetRepositoryTriggersCommand;
const de_GetRepositoryTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListApprovalRuleTemplatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListApprovalRuleTemplatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListApprovalRuleTemplatesCommand = de_ListApprovalRuleTemplatesCommand;
const de_ListApprovalRuleTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAssociatedApprovalRuleTemplatesForRepositoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListAssociatedApprovalRuleTemplatesForRepositoryCommand = de_ListAssociatedApprovalRuleTemplatesForRepositoryCommand;
const de_ListAssociatedApprovalRuleTemplatesForRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListBranchesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListBranchesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListBranchesCommand = de_ListBranchesCommand;
const de_ListBranchesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPullRequestsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPullRequestsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListPullRequestsCommand = de_ListPullRequestsCommand;
const de_ListPullRequestsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AuthorDoesNotExistException":
        case "com.amazonaws.codecommit#AuthorDoesNotExistException":
            throw await de_AuthorDoesNotExistExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidAuthorArnException":
        case "com.amazonaws.codecommit#InvalidAuthorArnException":
            throw await de_InvalidAuthorArnExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        case "InvalidPullRequestStatusException":
        case "com.amazonaws.codecommit#InvalidPullRequestStatusException":
            throw await de_InvalidPullRequestStatusExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListRepositoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRepositoriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRepositoriesCommand = de_ListRepositoriesCommand;
const de_ListRepositoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidOrderException":
        case "com.amazonaws.codecommit#InvalidOrderException":
            throw await de_InvalidOrderExceptionRes(parsedOutput, context);
        case "InvalidSortByException":
        case "com.amazonaws.codecommit#InvalidSortByException":
            throw await de_InvalidSortByExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListRepositoriesForApprovalRuleTemplateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRepositoriesForApprovalRuleTemplateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListRepositoriesForApprovalRuleTemplateCommand = de_ListRepositoriesForApprovalRuleTemplateCommand;
const de_ListRepositoriesForApprovalRuleTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "InvalidContinuationTokenException":
        case "com.amazonaws.codecommit#InvalidContinuationTokenException":
            throw await de_InvalidContinuationTokenExceptionRes(parsedOutput, context);
        case "InvalidMaxResultsException":
        case "com.amazonaws.codecommit#InvalidMaxResultsException":
            throw await de_InvalidMaxResultsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidResourceArnException":
        case "com.amazonaws.codecommit#InvalidResourceArnException":
            throw await de_InvalidResourceArnExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codecommit#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergeBranchesByFastForwardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergeBranchesByFastForwardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergeBranchesByFastForwardCommand = de_MergeBranchesByFastForwardCommand;
const de_MergeBranchesByFastForwardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidTargetBranchException":
        case "com.amazonaws.codecommit#InvalidTargetBranchException":
            throw await de_InvalidTargetBranchExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergeBranchesBySquashCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergeBranchesBySquashCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergeBranchesBySquashCommand = de_MergeBranchesBySquashCommand;
const de_MergeBranchesBySquashCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FileModeRequiredException":
        case "com.amazonaws.codecommit#FileModeRequiredException":
            throw await de_FileModeRequiredExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionException":
            throw await de_InvalidConflictResolutionExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidReplacementContentException":
        case "com.amazonaws.codecommit#InvalidReplacementContentException":
            throw await de_InvalidReplacementContentExceptionRes(parsedOutput, context);
        case "InvalidReplacementTypeException":
        case "com.amazonaws.codecommit#InvalidReplacementTypeException":
            throw await de_InvalidReplacementTypeExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidTargetBranchException":
        case "com.amazonaws.codecommit#InvalidTargetBranchException":
            throw await de_InvalidTargetBranchExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "MaximumConflictResolutionEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
            throw await de_MaximumConflictResolutionEntriesExceededExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MultipleConflictResolutionEntriesException":
        case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
            throw await de_MultipleConflictResolutionEntriesExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "ReplacementContentRequiredException":
        case "com.amazonaws.codecommit#ReplacementContentRequiredException":
            throw await de_ReplacementContentRequiredExceptionRes(parsedOutput, context);
        case "ReplacementTypeRequiredException":
        case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
            throw await de_ReplacementTypeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergeBranchesByThreeWayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergeBranchesByThreeWayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergeBranchesByThreeWayCommand = de_MergeBranchesByThreeWayCommand;
const de_MergeBranchesByThreeWayCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "CommitRequiredException":
        case "com.amazonaws.codecommit#CommitRequiredException":
            throw await de_CommitRequiredExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FileModeRequiredException":
        case "com.amazonaws.codecommit#FileModeRequiredException":
            throw await de_FileModeRequiredExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidCommitException":
        case "com.amazonaws.codecommit#InvalidCommitException":
            throw await de_InvalidCommitExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionException":
            throw await de_InvalidConflictResolutionExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidReplacementContentException":
        case "com.amazonaws.codecommit#InvalidReplacementContentException":
            throw await de_InvalidReplacementContentExceptionRes(parsedOutput, context);
        case "InvalidReplacementTypeException":
        case "com.amazonaws.codecommit#InvalidReplacementTypeException":
            throw await de_InvalidReplacementTypeExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidTargetBranchException":
        case "com.amazonaws.codecommit#InvalidTargetBranchException":
            throw await de_InvalidTargetBranchExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "MaximumConflictResolutionEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
            throw await de_MaximumConflictResolutionEntriesExceededExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MultipleConflictResolutionEntriesException":
        case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
            throw await de_MultipleConflictResolutionEntriesExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "ReplacementContentRequiredException":
        case "com.amazonaws.codecommit#ReplacementContentRequiredException":
            throw await de_ReplacementContentRequiredExceptionRes(parsedOutput, context);
        case "ReplacementTypeRequiredException":
        case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
            throw await de_ReplacementTypeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergePullRequestByFastForwardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergePullRequestByFastForwardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MergePullRequestByFastForwardOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergePullRequestByFastForwardCommand = de_MergePullRequestByFastForwardCommand;
const de_MergePullRequestByFastForwardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestApprovalRulesNotSatisfiedException":
        case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
            throw await de_PullRequestApprovalRulesNotSatisfiedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "ReferenceDoesNotExistException":
        case "com.amazonaws.codecommit#ReferenceDoesNotExistException":
            throw await de_ReferenceDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryNotAssociatedWithPullRequestException":
        case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
            throw await de_RepositoryNotAssociatedWithPullRequestExceptionRes(parsedOutput, context);
        case "TipOfSourceReferenceIsDifferentException":
        case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
            throw await de_TipOfSourceReferenceIsDifferentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergePullRequestBySquashCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergePullRequestBySquashCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MergePullRequestBySquashOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergePullRequestBySquashCommand = de_MergePullRequestBySquashCommand;
const de_MergePullRequestBySquashCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionException":
            throw await de_InvalidConflictResolutionExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidReplacementContentException":
        case "com.amazonaws.codecommit#InvalidReplacementContentException":
            throw await de_InvalidReplacementContentExceptionRes(parsedOutput, context);
        case "InvalidReplacementTypeException":
        case "com.amazonaws.codecommit#InvalidReplacementTypeException":
            throw await de_InvalidReplacementTypeExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "MaximumConflictResolutionEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
            throw await de_MaximumConflictResolutionEntriesExceededExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MultipleConflictResolutionEntriesException":
        case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
            throw await de_MultipleConflictResolutionEntriesExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestApprovalRulesNotSatisfiedException":
        case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
            throw await de_PullRequestApprovalRulesNotSatisfiedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "ReplacementContentRequiredException":
        case "com.amazonaws.codecommit#ReplacementContentRequiredException":
            throw await de_ReplacementContentRequiredExceptionRes(parsedOutput, context);
        case "ReplacementTypeRequiredException":
        case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
            throw await de_ReplacementTypeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryNotAssociatedWithPullRequestException":
        case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
            throw await de_RepositoryNotAssociatedWithPullRequestExceptionRes(parsedOutput, context);
        case "TipOfSourceReferenceIsDifferentException":
        case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
            throw await de_TipOfSourceReferenceIsDifferentExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_MergePullRequestByThreeWayCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_MergePullRequestByThreeWayCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_MergePullRequestByThreeWayOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_MergePullRequestByThreeWayCommand = de_MergePullRequestByThreeWayCommand;
const de_MergePullRequestByThreeWayCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "ConcurrentReferenceUpdateException":
        case "com.amazonaws.codecommit#ConcurrentReferenceUpdateException":
            throw await de_ConcurrentReferenceUpdateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidConflictDetailLevelException":
        case "com.amazonaws.codecommit#InvalidConflictDetailLevelException":
            throw await de_InvalidConflictDetailLevelExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionException":
            throw await de_InvalidConflictResolutionExceptionRes(parsedOutput, context);
        case "InvalidConflictResolutionStrategyException":
        case "com.amazonaws.codecommit#InvalidConflictResolutionStrategyException":
            throw await de_InvalidConflictResolutionStrategyExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidReplacementContentException":
        case "com.amazonaws.codecommit#InvalidReplacementContentException":
            throw await de_InvalidReplacementContentExceptionRes(parsedOutput, context);
        case "InvalidReplacementTypeException":
        case "com.amazonaws.codecommit#InvalidReplacementTypeException":
            throw await de_InvalidReplacementTypeExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "ManualMergeRequiredException":
        case "com.amazonaws.codecommit#ManualMergeRequiredException":
            throw await de_ManualMergeRequiredExceptionRes(parsedOutput, context);
        case "MaximumConflictResolutionEntriesExceededException":
        case "com.amazonaws.codecommit#MaximumConflictResolutionEntriesExceededException":
            throw await de_MaximumConflictResolutionEntriesExceededExceptionRes(parsedOutput, context);
        case "MaximumFileContentToLoadExceededException":
        case "com.amazonaws.codecommit#MaximumFileContentToLoadExceededException":
            throw await de_MaximumFileContentToLoadExceededExceptionRes(parsedOutput, context);
        case "MaximumItemsToCompareExceededException":
        case "com.amazonaws.codecommit#MaximumItemsToCompareExceededException":
            throw await de_MaximumItemsToCompareExceededExceptionRes(parsedOutput, context);
        case "MultipleConflictResolutionEntriesException":
        case "com.amazonaws.codecommit#MultipleConflictResolutionEntriesException":
            throw await de_MultipleConflictResolutionEntriesExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestApprovalRulesNotSatisfiedException":
        case "com.amazonaws.codecommit#PullRequestApprovalRulesNotSatisfiedException":
            throw await de_PullRequestApprovalRulesNotSatisfiedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "ReplacementContentRequiredException":
        case "com.amazonaws.codecommit#ReplacementContentRequiredException":
            throw await de_ReplacementContentRequiredExceptionRes(parsedOutput, context);
        case "ReplacementTypeRequiredException":
        case "com.amazonaws.codecommit#ReplacementTypeRequiredException":
            throw await de_ReplacementTypeRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryNotAssociatedWithPullRequestException":
        case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
            throw await de_RepositoryNotAssociatedWithPullRequestExceptionRes(parsedOutput, context);
        case "TipOfSourceReferenceIsDifferentException":
        case "com.amazonaws.codecommit#TipOfSourceReferenceIsDifferentException":
            throw await de_TipOfSourceReferenceIsDifferentExceptionRes(parsedOutput, context);
        case "TipsDivergenceExceededException":
        case "com.amazonaws.codecommit#TipsDivergenceExceededException":
            throw await de_TipsDivergenceExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_OverridePullRequestApprovalRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_OverridePullRequestApprovalRulesCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_OverridePullRequestApprovalRulesCommand = de_OverridePullRequestApprovalRulesCommand;
const de_OverridePullRequestApprovalRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidOverrideStatusException":
        case "com.amazonaws.codecommit#InvalidOverrideStatusException":
            throw await de_InvalidOverrideStatusExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRevisionIdException":
        case "com.amazonaws.codecommit#InvalidRevisionIdException":
            throw await de_InvalidRevisionIdExceptionRes(parsedOutput, context);
        case "OverrideAlreadySetException":
        case "com.amazonaws.codecommit#OverrideAlreadySetException":
            throw await de_OverrideAlreadySetExceptionRes(parsedOutput, context);
        case "OverrideStatusRequiredException":
        case "com.amazonaws.codecommit#OverrideStatusRequiredException":
            throw await de_OverrideStatusRequiredExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionIdRequiredException":
        case "com.amazonaws.codecommit#RevisionIdRequiredException":
            throw await de_RevisionIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionNotCurrentException":
        case "com.amazonaws.codecommit#RevisionNotCurrentException":
            throw await de_RevisionNotCurrentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PostCommentForComparedCommitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PostCommentForComparedCommitCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PostCommentForComparedCommitOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PostCommentForComparedCommitCommand = de_PostCommentForComparedCommitCommand;
const de_PostCommentForComparedCommitCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BeforeCommitIdAndAfterCommitIdAreSameException":
        case "com.amazonaws.codecommit#BeforeCommitIdAndAfterCommitIdAreSameException":
            throw await de_BeforeCommitIdAndAfterCommitIdAreSameExceptionRes(parsedOutput, context);
        case "ClientRequestTokenRequiredException":
        case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
            throw await de_ClientRequestTokenRequiredExceptionRes(parsedOutput, context);
        case "CommentContentRequiredException":
        case "com.amazonaws.codecommit#CommentContentRequiredException":
            throw await de_CommentContentRequiredExceptionRes(parsedOutput, context);
        case "CommentContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
            throw await de_CommentContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "IdempotencyParameterMismatchException":
        case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
            throw await de_IdempotencyParameterMismatchExceptionRes(parsedOutput, context);
        case "InvalidClientRequestTokenException":
        case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
            throw await de_InvalidClientRequestTokenExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidFileLocationException":
        case "com.amazonaws.codecommit#InvalidFileLocationException":
            throw await de_InvalidFileLocationExceptionRes(parsedOutput, context);
        case "InvalidFilePositionException":
        case "com.amazonaws.codecommit#InvalidFilePositionException":
            throw await de_InvalidFilePositionExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRelativeFileVersionEnumException":
        case "com.amazonaws.codecommit#InvalidRelativeFileVersionEnumException":
            throw await de_InvalidRelativeFileVersionEnumExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PathDoesNotExistException":
        case "com.amazonaws.codecommit#PathDoesNotExistException":
            throw await de_PathDoesNotExistExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PostCommentForPullRequestCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PostCommentForPullRequestCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PostCommentForPullRequestOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PostCommentForPullRequestCommand = de_PostCommentForPullRequestCommand;
const de_PostCommentForPullRequestCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BeforeCommitIdAndAfterCommitIdAreSameException":
        case "com.amazonaws.codecommit#BeforeCommitIdAndAfterCommitIdAreSameException":
            throw await de_BeforeCommitIdAndAfterCommitIdAreSameExceptionRes(parsedOutput, context);
        case "ClientRequestTokenRequiredException":
        case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
            throw await de_ClientRequestTokenRequiredExceptionRes(parsedOutput, context);
        case "CommentContentRequiredException":
        case "com.amazonaws.codecommit#CommentContentRequiredException":
            throw await de_CommentContentRequiredExceptionRes(parsedOutput, context);
        case "CommentContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
            throw await de_CommentContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "CommitDoesNotExistException":
        case "com.amazonaws.codecommit#CommitDoesNotExistException":
            throw await de_CommitDoesNotExistExceptionRes(parsedOutput, context);
        case "CommitIdRequiredException":
        case "com.amazonaws.codecommit#CommitIdRequiredException":
            throw await de_CommitIdRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "IdempotencyParameterMismatchException":
        case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
            throw await de_IdempotencyParameterMismatchExceptionRes(parsedOutput, context);
        case "InvalidClientRequestTokenException":
        case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
            throw await de_InvalidClientRequestTokenExceptionRes(parsedOutput, context);
        case "InvalidCommitIdException":
        case "com.amazonaws.codecommit#InvalidCommitIdException":
            throw await de_InvalidCommitIdExceptionRes(parsedOutput, context);
        case "InvalidFileLocationException":
        case "com.amazonaws.codecommit#InvalidFileLocationException":
            throw await de_InvalidFileLocationExceptionRes(parsedOutput, context);
        case "InvalidFilePositionException":
        case "com.amazonaws.codecommit#InvalidFilePositionException":
            throw await de_InvalidFilePositionExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRelativeFileVersionEnumException":
        case "com.amazonaws.codecommit#InvalidRelativeFileVersionEnumException":
            throw await de_InvalidRelativeFileVersionEnumExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "PathDoesNotExistException":
        case "com.amazonaws.codecommit#PathDoesNotExistException":
            throw await de_PathDoesNotExistExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryNotAssociatedWithPullRequestException":
        case "com.amazonaws.codecommit#RepositoryNotAssociatedWithPullRequestException":
            throw await de_RepositoryNotAssociatedWithPullRequestExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PostCommentReplyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PostCommentReplyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PostCommentReplyOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PostCommentReplyCommand = de_PostCommentReplyCommand;
const de_PostCommentReplyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientRequestTokenRequiredException":
        case "com.amazonaws.codecommit#ClientRequestTokenRequiredException":
            throw await de_ClientRequestTokenRequiredExceptionRes(parsedOutput, context);
        case "CommentContentRequiredException":
        case "com.amazonaws.codecommit#CommentContentRequiredException":
            throw await de_CommentContentRequiredExceptionRes(parsedOutput, context);
        case "CommentContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
            throw await de_CommentContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "IdempotencyParameterMismatchException":
        case "com.amazonaws.codecommit#IdempotencyParameterMismatchException":
            throw await de_IdempotencyParameterMismatchExceptionRes(parsedOutput, context);
        case "InvalidClientRequestTokenException":
        case "com.amazonaws.codecommit#InvalidClientRequestTokenException":
            throw await de_InvalidClientRequestTokenExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutCommentReactionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutCommentReactionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_PutCommentReactionCommand = de_PutCommentReactionCommand;
const de_PutCommentReactionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommentDeletedException":
        case "com.amazonaws.codecommit#CommentDeletedException":
            throw await de_CommentDeletedExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        case "InvalidReactionValueException":
        case "com.amazonaws.codecommit#InvalidReactionValueException":
            throw await de_InvalidReactionValueExceptionRes(parsedOutput, context);
        case "ReactionLimitExceededException":
        case "com.amazonaws.codecommit#ReactionLimitExceededException":
            throw await de_ReactionLimitExceededExceptionRes(parsedOutput, context);
        case "ReactionValueRequiredException":
        case "com.amazonaws.codecommit#ReactionValueRequiredException":
            throw await de_ReactionValueRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutFileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutFileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PutFileCommand = de_PutFileCommand;
const de_PutFileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameIsTagNameException":
        case "com.amazonaws.codecommit#BranchNameIsTagNameException":
            throw await de_BranchNameIsTagNameExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "CommitMessageLengthExceededException":
        case "com.amazonaws.codecommit#CommitMessageLengthExceededException":
            throw await de_CommitMessageLengthExceededExceptionRes(parsedOutput, context);
        case "DirectoryNameConflictsWithFileNameException":
        case "com.amazonaws.codecommit#DirectoryNameConflictsWithFileNameException":
            throw await de_DirectoryNameConflictsWithFileNameExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "FileContentRequiredException":
        case "com.amazonaws.codecommit#FileContentRequiredException":
            throw await de_FileContentRequiredExceptionRes(parsedOutput, context);
        case "FileContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FileContentSizeLimitExceededException":
            throw await de_FileContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "FileNameConflictsWithDirectoryNameException":
        case "com.amazonaws.codecommit#FileNameConflictsWithDirectoryNameException":
            throw await de_FileNameConflictsWithDirectoryNameExceptionRes(parsedOutput, context);
        case "FilePathConflictsWithSubmodulePathException":
        case "com.amazonaws.codecommit#FilePathConflictsWithSubmodulePathException":
            throw await de_FilePathConflictsWithSubmodulePathExceptionRes(parsedOutput, context);
        case "FolderContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#FolderContentSizeLimitExceededException":
            throw await de_FolderContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidDeletionParameterException":
        case "com.amazonaws.codecommit#InvalidDeletionParameterException":
            throw await de_InvalidDeletionParameterExceptionRes(parsedOutput, context);
        case "InvalidEmailException":
        case "com.amazonaws.codecommit#InvalidEmailException":
            throw await de_InvalidEmailExceptionRes(parsedOutput, context);
        case "InvalidFileModeException":
        case "com.amazonaws.codecommit#InvalidFileModeException":
            throw await de_InvalidFileModeExceptionRes(parsedOutput, context);
        case "InvalidParentCommitIdException":
        case "com.amazonaws.codecommit#InvalidParentCommitIdException":
            throw await de_InvalidParentCommitIdExceptionRes(parsedOutput, context);
        case "InvalidPathException":
        case "com.amazonaws.codecommit#InvalidPathException":
            throw await de_InvalidPathExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "NameLengthExceededException":
        case "com.amazonaws.codecommit#NameLengthExceededException":
            throw await de_NameLengthExceededExceptionRes(parsedOutput, context);
        case "ParentCommitDoesNotExistException":
        case "com.amazonaws.codecommit#ParentCommitDoesNotExistException":
            throw await de_ParentCommitDoesNotExistExceptionRes(parsedOutput, context);
        case "ParentCommitIdOutdatedException":
        case "com.amazonaws.codecommit#ParentCommitIdOutdatedException":
            throw await de_ParentCommitIdOutdatedExceptionRes(parsedOutput, context);
        case "ParentCommitIdRequiredException":
        case "com.amazonaws.codecommit#ParentCommitIdRequiredException":
            throw await de_ParentCommitIdRequiredExceptionRes(parsedOutput, context);
        case "PathRequiredException":
        case "com.amazonaws.codecommit#PathRequiredException":
            throw await de_PathRequiredExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "SameFileContentException":
        case "com.amazonaws.codecommit#SameFileContentException":
            throw await de_SameFileContentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutRepositoryTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutRepositoryTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_PutRepositoryTriggersCommand = de_PutRepositoryTriggersCommand;
const de_PutRepositoryTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerBranchNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerBranchNameException":
            throw await de_InvalidRepositoryTriggerBranchNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerCustomDataException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerCustomDataException":
            throw await de_InvalidRepositoryTriggerCustomDataExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerDestinationArnException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerDestinationArnException":
            throw await de_InvalidRepositoryTriggerDestinationArnExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerEventsException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerEventsException":
            throw await de_InvalidRepositoryTriggerEventsExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerNameException":
            throw await de_InvalidRepositoryTriggerNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerRegionException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerRegionException":
            throw await de_InvalidRepositoryTriggerRegionExceptionRes(parsedOutput, context);
        case "MaximumBranchesExceededException":
        case "com.amazonaws.codecommit#MaximumBranchesExceededException":
            throw await de_MaximumBranchesExceededExceptionRes(parsedOutput, context);
        case "MaximumRepositoryTriggersExceededException":
        case "com.amazonaws.codecommit#MaximumRepositoryTriggersExceededException":
            throw await de_MaximumRepositoryTriggersExceededExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerBranchNameListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerBranchNameListRequiredException":
            throw await de_RepositoryTriggerBranchNameListRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerDestinationArnRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerDestinationArnRequiredException":
            throw await de_RepositoryTriggerDestinationArnRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerEventsListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerEventsListRequiredException":
            throw await de_RepositoryTriggerEventsListRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerNameRequiredException":
            throw await de_RepositoryTriggerNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggersListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggersListRequiredException":
            throw await de_RepositoryTriggersListRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidResourceArnException":
        case "com.amazonaws.codecommit#InvalidResourceArnException":
            throw await de_InvalidResourceArnExceptionRes(parsedOutput, context);
        case "InvalidSystemTagUsageException":
        case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
            throw await de_InvalidSystemTagUsageExceptionRes(parsedOutput, context);
        case "InvalidTagsMapException":
        case "com.amazonaws.codecommit#InvalidTagsMapException":
            throw await de_InvalidTagsMapExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codecommit#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        case "TagPolicyException":
        case "com.amazonaws.codecommit#TagPolicyException":
            throw await de_TagPolicyExceptionRes(parsedOutput, context);
        case "TagsMapRequiredException":
        case "com.amazonaws.codecommit#TagsMapRequiredException":
            throw await de_TagsMapRequiredExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.codecommit#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TestRepositoryTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TestRepositoryTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_TestRepositoryTriggersCommand = de_TestRepositoryTriggersCommand;
const de_TestRepositoryTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerBranchNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerBranchNameException":
            throw await de_InvalidRepositoryTriggerBranchNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerCustomDataException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerCustomDataException":
            throw await de_InvalidRepositoryTriggerCustomDataExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerDestinationArnException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerDestinationArnException":
            throw await de_InvalidRepositoryTriggerDestinationArnExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerEventsException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerEventsException":
            throw await de_InvalidRepositoryTriggerEventsExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerNameException":
            throw await de_InvalidRepositoryTriggerNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryTriggerRegionException":
        case "com.amazonaws.codecommit#InvalidRepositoryTriggerRegionException":
            throw await de_InvalidRepositoryTriggerRegionExceptionRes(parsedOutput, context);
        case "MaximumBranchesExceededException":
        case "com.amazonaws.codecommit#MaximumBranchesExceededException":
            throw await de_MaximumBranchesExceededExceptionRes(parsedOutput, context);
        case "MaximumRepositoryTriggersExceededException":
        case "com.amazonaws.codecommit#MaximumRepositoryTriggersExceededException":
            throw await de_MaximumRepositoryTriggersExceededExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerBranchNameListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerBranchNameListRequiredException":
            throw await de_RepositoryTriggerBranchNameListRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerDestinationArnRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerDestinationArnRequiredException":
            throw await de_RepositoryTriggerDestinationArnRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerEventsListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerEventsListRequiredException":
            throw await de_RepositoryTriggerEventsListRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggerNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggerNameRequiredException":
            throw await de_RepositoryTriggerNameRequiredExceptionRes(parsedOutput, context);
        case "RepositoryTriggersListRequiredException":
        case "com.amazonaws.codecommit#RepositoryTriggersListRequiredException":
            throw await de_RepositoryTriggersListRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "InvalidResourceArnException":
        case "com.amazonaws.codecommit#InvalidResourceArnException":
            throw await de_InvalidResourceArnExceptionRes(parsedOutput, context);
        case "InvalidSystemTagUsageException":
        case "com.amazonaws.codecommit#InvalidSystemTagUsageException":
            throw await de_InvalidSystemTagUsageExceptionRes(parsedOutput, context);
        case "InvalidTagKeysListException":
        case "com.amazonaws.codecommit#InvalidTagKeysListException":
            throw await de_InvalidTagKeysListExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codecommit#ResourceArnRequiredException":
            throw await de_ResourceArnRequiredExceptionRes(parsedOutput, context);
        case "TagKeysListRequiredException":
        case "com.amazonaws.codecommit#TagKeysListRequiredException":
            throw await de_TagKeysListRequiredExceptionRes(parsedOutput, context);
        case "TagPolicyException":
        case "com.amazonaws.codecommit#TagPolicyException":
            throw await de_TagPolicyExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.codecommit#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApprovalRuleTemplateContentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateApprovalRuleTemplateContentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateApprovalRuleTemplateContentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateApprovalRuleTemplateContentCommand = de_UpdateApprovalRuleTemplateContentCommand;
const de_UpdateApprovalRuleTemplateContentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateContentRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateContentRequiredException":
            throw await de_ApprovalRuleTemplateContentRequiredExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateContentException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateContentException":
            throw await de_InvalidApprovalRuleTemplateContentExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        case "InvalidRuleContentSha256Exception":
        case "com.amazonaws.codecommit#InvalidRuleContentSha256Exception":
            throw await de_InvalidRuleContentSha256ExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApprovalRuleTemplateDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateApprovalRuleTemplateDescriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateApprovalRuleTemplateDescriptionOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateApprovalRuleTemplateDescriptionCommand = de_UpdateApprovalRuleTemplateDescriptionCommand;
const de_UpdateApprovalRuleTemplateDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateDescriptionException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateDescriptionException":
            throw await de_InvalidApprovalRuleTemplateDescriptionExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateApprovalRuleTemplateNameCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateApprovalRuleTemplateNameCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateApprovalRuleTemplateNameOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateApprovalRuleTemplateNameCommand = de_UpdateApprovalRuleTemplateNameCommand;
const de_UpdateApprovalRuleTemplateNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleTemplateDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateDoesNotExistException":
            throw await de_ApprovalRuleTemplateDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameAlreadyExistsException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameAlreadyExistsException":
            throw await de_ApprovalRuleTemplateNameAlreadyExistsExceptionRes(parsedOutput, context);
        case "ApprovalRuleTemplateNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleTemplateNameRequiredException":
            throw await de_ApprovalRuleTemplateNameRequiredExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleTemplateNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleTemplateNameException":
            throw await de_InvalidApprovalRuleTemplateNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateCommentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateCommentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateCommentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdateCommentCommand = de_UpdateCommentCommand;
const de_UpdateCommentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CommentContentRequiredException":
        case "com.amazonaws.codecommit#CommentContentRequiredException":
            throw await de_CommentContentRequiredExceptionRes(parsedOutput, context);
        case "CommentContentSizeLimitExceededException":
        case "com.amazonaws.codecommit#CommentContentSizeLimitExceededException":
            throw await de_CommentContentSizeLimitExceededExceptionRes(parsedOutput, context);
        case "CommentDeletedException":
        case "com.amazonaws.codecommit#CommentDeletedException":
            throw await de_CommentDeletedExceptionRes(parsedOutput, context);
        case "CommentDoesNotExistException":
        case "com.amazonaws.codecommit#CommentDoesNotExistException":
            throw await de_CommentDoesNotExistExceptionRes(parsedOutput, context);
        case "CommentIdRequiredException":
        case "com.amazonaws.codecommit#CommentIdRequiredException":
            throw await de_CommentIdRequiredExceptionRes(parsedOutput, context);
        case "CommentNotCreatedByCallerException":
        case "com.amazonaws.codecommit#CommentNotCreatedByCallerException":
            throw await de_CommentNotCreatedByCallerExceptionRes(parsedOutput, context);
        case "InvalidCommentIdException":
        case "com.amazonaws.codecommit#InvalidCommentIdException":
            throw await de_InvalidCommentIdExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDefaultBranchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateDefaultBranchCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateDefaultBranchCommand = de_UpdateDefaultBranchCommand;
const de_UpdateDefaultBranchCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BranchDoesNotExistException":
        case "com.amazonaws.codecommit#BranchDoesNotExistException":
            throw await de_BranchDoesNotExistExceptionRes(parsedOutput, context);
        case "BranchNameRequiredException":
        case "com.amazonaws.codecommit#BranchNameRequiredException":
            throw await de_BranchNameRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidBranchNameException":
        case "com.amazonaws.codecommit#InvalidBranchNameException":
            throw await de_InvalidBranchNameExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePullRequestApprovalRuleContentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePullRequestApprovalRuleContentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdatePullRequestApprovalRuleContentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdatePullRequestApprovalRuleContentCommand = de_UpdatePullRequestApprovalRuleContentCommand;
const de_UpdatePullRequestApprovalRuleContentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalRuleContentRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleContentRequiredException":
            throw await de_ApprovalRuleContentRequiredExceptionRes(parsedOutput, context);
        case "ApprovalRuleDoesNotExistException":
        case "com.amazonaws.codecommit#ApprovalRuleDoesNotExistException":
            throw await de_ApprovalRuleDoesNotExistExceptionRes(parsedOutput, context);
        case "ApprovalRuleNameRequiredException":
        case "com.amazonaws.codecommit#ApprovalRuleNameRequiredException":
            throw await de_ApprovalRuleNameRequiredExceptionRes(parsedOutput, context);
        case "CannotModifyApprovalRuleFromTemplateException":
        case "com.amazonaws.codecommit#CannotModifyApprovalRuleFromTemplateException":
            throw await de_CannotModifyApprovalRuleFromTemplateExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleContentException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleContentException":
            throw await de_InvalidApprovalRuleContentExceptionRes(parsedOutput, context);
        case "InvalidApprovalRuleNameException":
        case "com.amazonaws.codecommit#InvalidApprovalRuleNameException":
            throw await de_InvalidApprovalRuleNameExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRuleContentSha256Exception":
        case "com.amazonaws.codecommit#InvalidRuleContentSha256Exception":
            throw await de_InvalidRuleContentSha256ExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePullRequestApprovalStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePullRequestApprovalStateCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdatePullRequestApprovalStateCommand = de_UpdatePullRequestApprovalStateCommand;
const de_UpdatePullRequestApprovalStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApprovalStateRequiredException":
        case "com.amazonaws.codecommit#ApprovalStateRequiredException":
            throw await de_ApprovalStateRequiredExceptionRes(parsedOutput, context);
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidApprovalStateException":
        case "com.amazonaws.codecommit#InvalidApprovalStateException":
            throw await de_InvalidApprovalStateExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidRevisionIdException":
        case "com.amazonaws.codecommit#InvalidRevisionIdException":
            throw await de_InvalidRevisionIdExceptionRes(parsedOutput, context);
        case "MaximumNumberOfApprovalsExceededException":
        case "com.amazonaws.codecommit#MaximumNumberOfApprovalsExceededException":
            throw await de_MaximumNumberOfApprovalsExceededExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestCannotBeApprovedByAuthorException":
        case "com.amazonaws.codecommit#PullRequestCannotBeApprovedByAuthorException":
            throw await de_PullRequestCannotBeApprovedByAuthorExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionIdRequiredException":
        case "com.amazonaws.codecommit#RevisionIdRequiredException":
            throw await de_RevisionIdRequiredExceptionRes(parsedOutput, context);
        case "RevisionNotCurrentException":
        case "com.amazonaws.codecommit#RevisionNotCurrentException":
            throw await de_RevisionNotCurrentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePullRequestDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePullRequestDescriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdatePullRequestDescriptionOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdatePullRequestDescriptionCommand = de_UpdatePullRequestDescriptionCommand;
const de_UpdatePullRequestDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidDescriptionException":
        case "com.amazonaws.codecommit#InvalidDescriptionException":
            throw await de_InvalidDescriptionExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePullRequestStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePullRequestStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdatePullRequestStatusOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdatePullRequestStatusCommand = de_UpdatePullRequestStatusCommand;
const de_UpdatePullRequestStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidPullRequestStatusException":
        case "com.amazonaws.codecommit#InvalidPullRequestStatusException":
            throw await de_InvalidPullRequestStatusExceptionRes(parsedOutput, context);
        case "InvalidPullRequestStatusUpdateException":
        case "com.amazonaws.codecommit#InvalidPullRequestStatusUpdateException":
            throw await de_InvalidPullRequestStatusUpdateExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "PullRequestStatusRequiredException":
        case "com.amazonaws.codecommit#PullRequestStatusRequiredException":
            throw await de_PullRequestStatusRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePullRequestTitleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePullRequestTitleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdatePullRequestTitleOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_UpdatePullRequestTitleCommand = de_UpdatePullRequestTitleCommand;
const de_UpdatePullRequestTitleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidPullRequestIdException":
        case "com.amazonaws.codecommit#InvalidPullRequestIdException":
            throw await de_InvalidPullRequestIdExceptionRes(parsedOutput, context);
        case "InvalidTitleException":
        case "com.amazonaws.codecommit#InvalidTitleException":
            throw await de_InvalidTitleExceptionRes(parsedOutput, context);
        case "PullRequestAlreadyClosedException":
        case "com.amazonaws.codecommit#PullRequestAlreadyClosedException":
            throw await de_PullRequestAlreadyClosedExceptionRes(parsedOutput, context);
        case "PullRequestDoesNotExistException":
        case "com.amazonaws.codecommit#PullRequestDoesNotExistException":
            throw await de_PullRequestDoesNotExistExceptionRes(parsedOutput, context);
        case "PullRequestIdRequiredException":
        case "com.amazonaws.codecommit#PullRequestIdRequiredException":
            throw await de_PullRequestIdRequiredExceptionRes(parsedOutput, context);
        case "TitleRequiredException":
        case "com.amazonaws.codecommit#TitleRequiredException":
            throw await de_TitleRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRepositoryDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRepositoryDescriptionCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateRepositoryDescriptionCommand = de_UpdateRepositoryDescriptionCommand;
const de_UpdateRepositoryDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EncryptionIntegrityChecksFailedException":
        case "com.amazonaws.codecommit#EncryptionIntegrityChecksFailedException":
            throw await de_EncryptionIntegrityChecksFailedExceptionRes(parsedOutput, context);
        case "EncryptionKeyAccessDeniedException":
        case "com.amazonaws.codecommit#EncryptionKeyAccessDeniedException":
            throw await de_EncryptionKeyAccessDeniedExceptionRes(parsedOutput, context);
        case "EncryptionKeyDisabledException":
        case "com.amazonaws.codecommit#EncryptionKeyDisabledException":
            throw await de_EncryptionKeyDisabledExceptionRes(parsedOutput, context);
        case "EncryptionKeyNotFoundException":
        case "com.amazonaws.codecommit#EncryptionKeyNotFoundException":
            throw await de_EncryptionKeyNotFoundExceptionRes(parsedOutput, context);
        case "EncryptionKeyUnavailableException":
        case "com.amazonaws.codecommit#EncryptionKeyUnavailableException":
            throw await de_EncryptionKeyUnavailableExceptionRes(parsedOutput, context);
        case "InvalidRepositoryDescriptionException":
        case "com.amazonaws.codecommit#InvalidRepositoryDescriptionException":
            throw await de_InvalidRepositoryDescriptionExceptionRes(parsedOutput, context);
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRepositoryNameCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRepositoryNameCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
exports.de_UpdateRepositoryNameCommand = de_UpdateRepositoryNameCommand;
const de_UpdateRepositoryNameCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRepositoryNameException":
        case "com.amazonaws.codecommit#InvalidRepositoryNameException":
            throw await de_InvalidRepositoryNameExceptionRes(parsedOutput, context);
        case "RepositoryDoesNotExistException":
        case "com.amazonaws.codecommit#RepositoryDoesNotExistException":
            throw await de_RepositoryDoesNotExistExceptionRes(parsedOutput, context);
        case "RepositoryNameExistsException":
        case "com.amazonaws.codecommit#RepositoryNameExistsException":
            throw await de_RepositoryNameExistsExceptionRes(parsedOutput, context);
        case "RepositoryNameRequiredException":
        case "com.amazonaws.codecommit#RepositoryNameRequiredException":
            throw await de_RepositoryNameRequiredExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ActorDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ActorDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleNameAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleNameAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleTemplateContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleTemplateContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleTemplateDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleTemplateDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleTemplateInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleTemplateInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleTemplateNameAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleTemplateNameAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalRuleTemplateNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalRuleTemplateNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ApprovalStateRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ApprovalStateRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_AuthorDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.AuthorDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BeforeCommitIdAndAfterCommitIdAreSameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BeforeCommitIdAndAfterCommitIdAreSameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BlobIdDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BlobIdDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BlobIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BlobIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BranchDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BranchDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BranchNameExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BranchNameExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BranchNameIsTagNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BranchNameIsTagNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_BranchNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.BranchNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CannotDeleteApprovalRuleFromTemplateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CannotDeleteApprovalRuleFromTemplateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CannotModifyApprovalRuleFromTemplateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CannotModifyApprovalRuleFromTemplateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ClientRequestTokenRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ClientRequestTokenRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.CommentContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentContentSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.CommentContentSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentDeletedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommentDeletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommentDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommentIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommentNotCreatedByCallerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.CommentNotCreatedByCallerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitIdDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitIdDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitIdsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitIdsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitIdsListRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitIdsListRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitMessageLengthExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitMessageLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CommitRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CommitRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ConcurrentReferenceUpdateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ConcurrentReferenceUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DefaultBranchCannotBeDeletedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DefaultBranchCannotBeDeletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DirectoryNameConflictsWithFileNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DirectoryNameConflictsWithFileNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EncryptionIntegrityChecksFailedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.EncryptionIntegrityChecksFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EncryptionKeyAccessDeniedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.EncryptionKeyAccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EncryptionKeyDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.EncryptionKeyDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EncryptionKeyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.EncryptionKeyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EncryptionKeyUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.EncryptionKeyUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileContentAndSourceFileSpecifiedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileContentAndSourceFileSpecifiedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.FileContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileContentSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileContentSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileEntryRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileEntryRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileModeRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileModeRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileNameConflictsWithDirectoryNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileNameConflictsWithDirectoryNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FilePathConflictsWithSubmodulePathExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FilePathConflictsWithSubmodulePathException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FileTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FileTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FolderContentSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FolderContentSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_FolderDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.FolderDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IdempotencyParameterMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.IdempotencyParameterMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidActorArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidActorArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalRuleContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApprovalRuleContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalRuleNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApprovalRuleNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalRuleTemplateContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApprovalRuleTemplateContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalRuleTemplateDescriptionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApprovalRuleTemplateDescriptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalRuleTemplateNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidApprovalRuleTemplateNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidApprovalStateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidApprovalStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAuthorArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidAuthorArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidBlobIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidBlobIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidBranchNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidBranchNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidClientRequestTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidClientRequestTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidCommentIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidCommentIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidCommitExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidCommitException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidCommitIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidCommitIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidConflictDetailLevelExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidConflictDetailLevelException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidConflictResolutionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidConflictResolutionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidConflictResolutionStrategyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidConflictResolutionStrategyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidContinuationTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidContinuationTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDeletionParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDeletionParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDescriptionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDescriptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidDestinationCommitSpecifierExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidDestinationCommitSpecifierException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidEmailExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidEmailException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidFileLocationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidFileLocationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidFileModeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidFileModeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidFilePositionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidFilePositionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMaxConflictFilesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMaxConflictFilesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMaxMergeHunksExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMaxMergeHunksException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMaxResultsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMaxResultsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidMergeOptionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidMergeOptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidOrderExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidOrderException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidOverrideStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidOverrideStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidParentCommitIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidParentCommitIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPathExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidPathException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPullRequestEventTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidPullRequestEventTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPullRequestIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidPullRequestIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPullRequestStatusExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidPullRequestStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPullRequestStatusUpdateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidPullRequestStatusUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidReactionUserArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidReactionUserArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidReactionValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidReactionValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidReferenceNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidReferenceNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRelativeFileVersionEnumExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRelativeFileVersionEnumException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidReplacementContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidReplacementContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidReplacementTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidReplacementTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryDescriptionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRepositoryDescriptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRepositoryNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerBranchNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerBranchNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerCustomDataExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerCustomDataException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerDestinationArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerDestinationArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerEventsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerEventsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRepositoryTriggerRegionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRepositoryTriggerRegionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidResourceArnExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidResourceArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRevisionIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidRevisionIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidRuleContentSha256ExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidRuleContentSha256Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSortByExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSortByException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSourceCommitSpecifierExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSourceCommitSpecifierException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSystemTagUsageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSystemTagUsageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTagKeysListExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidTagKeysListException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTagsMapExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTagsMapException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetBranchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.InvalidTargetBranchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTargetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTargetsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTitleExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidTitleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ManualMergeRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ManualMergeRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumBranchesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.MaximumBranchesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumConflictResolutionEntriesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumConflictResolutionEntriesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumFileContentToLoadExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumFileContentToLoadExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumFileEntriesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumFileEntriesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumItemsToCompareExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumItemsToCompareExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumNumberOfApprovalsExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.MaximumNumberOfApprovalsExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumOpenPullRequestsExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumOpenPullRequestsExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumRepositoryNamesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumRepositoryNamesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumRepositoryTriggersExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.MaximumRepositoryTriggersExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MaximumRuleTemplatesAssociatedWithRepositoryExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MaximumRuleTemplatesAssociatedWithRepositoryException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MergeOptionRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MergeOptionRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MultipleConflictResolutionEntriesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MultipleConflictResolutionEntriesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MultipleRepositoriesInPullRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MultipleRepositoriesInPullRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NameLengthExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NameLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NoChangeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NoChangeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NumberOfRulesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NumberOfRulesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NumberOfRuleTemplatesExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NumberOfRuleTemplatesExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_OverrideAlreadySetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.OverrideAlreadySetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_OverrideStatusRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.OverrideStatusRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ParentCommitDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ParentCommitDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ParentCommitIdOutdatedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ParentCommitIdOutdatedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ParentCommitIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ParentCommitIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PathDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PathDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PathRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PathRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestAlreadyClosedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PullRequestAlreadyClosedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestApprovalRulesNotSatisfiedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.PullRequestApprovalRulesNotSatisfiedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestCannotBeApprovedByAuthorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.PullRequestCannotBeApprovedByAuthorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PullRequestDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PullRequestIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PullRequestStatusRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.PullRequestStatusRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PutFileEntryConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PutFileEntryConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReactionLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.ReactionLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReactionValueRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.ReactionValueRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReferenceDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ReferenceDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReferenceNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ReferenceNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReferenceTypeNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ReferenceTypeNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReplacementContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ReplacementContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ReplacementTypeRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ReplacementTypeRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryDoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryNameExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryNameExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryNamesRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryNamesRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryNotAssociatedWithPullRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RepositoryNotAssociatedWithPullRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryTriggerBranchNameListRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.RepositoryTriggerBranchNameListRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryTriggerDestinationArnRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.RepositoryTriggerDestinationArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryTriggerEventsListRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.RepositoryTriggerEventsListRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryTriggerNameRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.RepositoryTriggerNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RepositoryTriggersListRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.RepositoryTriggersListRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceArnRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.ResourceArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RestrictedSourceFileExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RestrictedSourceFileException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RevisionIdRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RevisionIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RevisionNotCurrentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.RevisionNotCurrentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SameFileContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.SameFileContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SamePathRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.SamePathRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SourceAndDestinationAreSameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.SourceAndDestinationAreSameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SourceFileOrContentRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.SourceFileOrContentRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagKeysListRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.TagKeysListRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagPolicyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TagPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TagsMapRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.TagsMapRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TargetRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TargetRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TargetsRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TargetsRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TipOfSourceReferenceIsDifferentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.TipOfSourceReferenceIsDifferentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TipsDivergenceExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TipsDivergenceExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TitleRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TitleRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_ConflictResolution = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        deleteFiles: smithy_client_1._json,
        replaceContents: (_) => se_ReplaceContentEntries(_, context),
        setFileModes: smithy_client_1._json,
    });
};
const se_CreateCommitInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        branchName: [],
        commitMessage: [],
        deleteFiles: smithy_client_1._json,
        email: [],
        keepEmptyFolders: [],
        parentCommitId: [],
        putFiles: (_) => se_PutFileEntries(_, context),
        repositoryName: [],
        setFileModes: smithy_client_1._json,
    });
};
const se_CreatePullRequestInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        description: [],
        targets: smithy_client_1._json,
        title: [],
    });
};
const se_CreateUnreferencedMergeCommitInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        commitMessage: [],
        conflictDetailLevel: [],
        conflictResolution: (_) => se_ConflictResolution(_, context),
        conflictResolutionStrategy: [],
        destinationCommitSpecifier: [],
        email: [],
        keepEmptyFolders: [],
        mergeOption: [],
        repositoryName: [],
        sourceCommitSpecifier: [],
    });
};
const se_MergeBranchesBySquashInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        commitMessage: [],
        conflictDetailLevel: [],
        conflictResolution: (_) => se_ConflictResolution(_, context),
        conflictResolutionStrategy: [],
        destinationCommitSpecifier: [],
        email: [],
        keepEmptyFolders: [],
        repositoryName: [],
        sourceCommitSpecifier: [],
        targetBranch: [],
    });
};
const se_MergeBranchesByThreeWayInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        commitMessage: [],
        conflictDetailLevel: [],
        conflictResolution: (_) => se_ConflictResolution(_, context),
        conflictResolutionStrategy: [],
        destinationCommitSpecifier: [],
        email: [],
        keepEmptyFolders: [],
        repositoryName: [],
        sourceCommitSpecifier: [],
        targetBranch: [],
    });
};
const se_MergePullRequestBySquashInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        commitMessage: [],
        conflictDetailLevel: [],
        conflictResolution: (_) => se_ConflictResolution(_, context),
        conflictResolutionStrategy: [],
        email: [],
        keepEmptyFolders: [],
        pullRequestId: [],
        repositoryName: [],
        sourceCommitId: [],
    });
};
const se_MergePullRequestByThreeWayInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        authorName: [],
        commitMessage: [],
        conflictDetailLevel: [],
        conflictResolution: (_) => se_ConflictResolution(_, context),
        conflictResolutionStrategy: [],
        email: [],
        keepEmptyFolders: [],
        pullRequestId: [],
        repositoryName: [],
        sourceCommitId: [],
    });
};
const se_PostCommentForComparedCommitInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        afterCommitId: [],
        beforeCommitId: [],
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        content: [],
        location: smithy_client_1._json,
        repositoryName: [],
    });
};
const se_PostCommentForPullRequestInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        afterCommitId: [],
        beforeCommitId: [],
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        content: [],
        location: smithy_client_1._json,
        pullRequestId: [],
        repositoryName: [],
    });
};
const se_PostCommentReplyInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        content: [],
        inReplyTo: [],
    });
};
const se_PutFileEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PutFileEntry(entry, context);
    });
};
const se_PutFileEntry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        fileContent: context.base64Encoder,
        fileMode: [],
        filePath: [],
        sourceFile: smithy_client_1._json,
    });
};
const se_PutFileInput = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        branchName: [],
        commitMessage: [],
        email: [],
        fileContent: context.base64Encoder,
        fileMode: [],
        filePath: [],
        name: [],
        parentCommitId: [],
        repositoryName: [],
    });
};
const se_ReplaceContentEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ReplaceContentEntry(entry, context);
    });
};
const se_ReplaceContentEntry = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        content: context.base64Encoder,
        fileMode: [],
        filePath: [],
        replacementType: [],
    });
};
const de_ApprovalRule = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleContent: smithy_client_1.expectString,
        approvalRuleId: smithy_client_1.expectString,
        approvalRuleName: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedUser: smithy_client_1.expectString,
        originApprovalRuleTemplate: smithy_client_1._json,
        ruleContentSha256: smithy_client_1.expectString,
    });
};
const de_ApprovalRulesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApprovalRule(entry, context);
    });
    return retVal;
};
const de_ApprovalRuleTemplate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplateContent: smithy_client_1.expectString,
        approvalRuleTemplateDescription: smithy_client_1.expectString,
        approvalRuleTemplateId: smithy_client_1.expectString,
        approvalRuleTemplateName: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedUser: smithy_client_1.expectString,
        ruleContentSha256: smithy_client_1.expectString,
    });
};
const de_BatchGetRepositoriesOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        repositories: (_) => de_RepositoryMetadataList(_, context),
        repositoriesNotFound: smithy_client_1._json,
    });
};
const de_Comment = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        authorArn: smithy_client_1.expectString,
        callerReactions: smithy_client_1._json,
        clientRequestToken: smithy_client_1.expectString,
        commentId: smithy_client_1.expectString,
        content: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deleted: smithy_client_1.expectBoolean,
        inReplyTo: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        reactionCounts: smithy_client_1._json,
    });
};
const de_Comments = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Comment(entry, context);
    });
    return retVal;
};
const de_CommentsForComparedCommit = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        afterBlobId: smithy_client_1.expectString,
        afterCommitId: smithy_client_1.expectString,
        beforeBlobId: smithy_client_1.expectString,
        beforeCommitId: smithy_client_1.expectString,
        comments: (_) => de_Comments(_, context),
        location: smithy_client_1._json,
        repositoryName: smithy_client_1.expectString,
    });
};
const de_CommentsForComparedCommitData = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CommentsForComparedCommit(entry, context);
    });
    return retVal;
};
const de_CommentsForPullRequest = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        afterBlobId: smithy_client_1.expectString,
        afterCommitId: smithy_client_1.expectString,
        beforeBlobId: smithy_client_1.expectString,
        beforeCommitId: smithy_client_1.expectString,
        comments: (_) => de_Comments(_, context),
        location: smithy_client_1._json,
        pullRequestId: smithy_client_1.expectString,
        repositoryName: smithy_client_1.expectString,
    });
};
const de_CommentsForPullRequestData = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CommentsForPullRequest(entry, context);
    });
    return retVal;
};
const de_CreateApprovalRuleTemplateOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplate: (_) => de_ApprovalRuleTemplate(_, context),
    });
};
const de_CreatePullRequestApprovalRuleOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRule: (_) => de_ApprovalRule(_, context),
    });
};
const de_CreatePullRequestOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_CreateRepositoryOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        repositoryMetadata: (_) => de_RepositoryMetadata(_, context),
    });
};
const de_DeleteCommentContentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        comment: (_) => de_Comment(_, context),
    });
};
const de_DescribePullRequestEventsOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        nextToken: smithy_client_1.expectString,
        pullRequestEvents: (_) => de_PullRequestEventList(_, context),
    });
};
const de_GetApprovalRuleTemplateOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplate: (_) => de_ApprovalRuleTemplate(_, context),
    });
};
const de_GetBlobOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        content: context.base64Decoder,
    });
};
const de_GetCommentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        comment: (_) => de_Comment(_, context),
    });
};
const de_GetCommentsForComparedCommitOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        commentsForComparedCommitData: (_) => de_CommentsForComparedCommitData(_, context),
        nextToken: smithy_client_1.expectString,
    });
};
const de_GetCommentsForPullRequestOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        commentsForPullRequestData: (_) => de_CommentsForPullRequestData(_, context),
        nextToken: smithy_client_1.expectString,
    });
};
const de_GetFileOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        blobId: smithy_client_1.expectString,
        commitId: smithy_client_1.expectString,
        fileContent: context.base64Decoder,
        fileMode: smithy_client_1.expectString,
        filePath: smithy_client_1.expectString,
        fileSize: smithy_client_1.expectLong,
    });
};
const de_GetPullRequestOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_GetRepositoryOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        repositoryMetadata: (_) => de_RepositoryMetadata(_, context),
    });
};
const de_MergePullRequestByFastForwardOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_MergePullRequestBySquashOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_MergePullRequestByThreeWayOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_PostCommentForComparedCommitOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        afterBlobId: smithy_client_1.expectString,
        afterCommitId: smithy_client_1.expectString,
        beforeBlobId: smithy_client_1.expectString,
        beforeCommitId: smithy_client_1.expectString,
        comment: (_) => de_Comment(_, context),
        location: smithy_client_1._json,
        repositoryName: smithy_client_1.expectString,
    });
};
const de_PostCommentForPullRequestOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        afterBlobId: smithy_client_1.expectString,
        afterCommitId: smithy_client_1.expectString,
        beforeBlobId: smithy_client_1.expectString,
        beforeCommitId: smithy_client_1.expectString,
        comment: (_) => de_Comment(_, context),
        location: smithy_client_1._json,
        pullRequestId: smithy_client_1.expectString,
        repositoryName: smithy_client_1.expectString,
    });
};
const de_PostCommentReplyOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        comment: (_) => de_Comment(_, context),
    });
};
const de_PullRequest = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRules: (_) => de_ApprovalRulesList(_, context),
        authorArn: smithy_client_1.expectString,
        clientRequestToken: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        lastActivityDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pullRequestId: smithy_client_1.expectString,
        pullRequestStatus: smithy_client_1.expectString,
        pullRequestTargets: smithy_client_1._json,
        revisionId: smithy_client_1.expectString,
        title: smithy_client_1.expectString,
    });
};
const de_PullRequestEvent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actorArn: smithy_client_1.expectString,
        approvalRuleEventMetadata: smithy_client_1._json,
        approvalRuleOverriddenEventMetadata: smithy_client_1._json,
        approvalStateChangedEventMetadata: smithy_client_1._json,
        eventDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        pullRequestCreatedEventMetadata: smithy_client_1._json,
        pullRequestEventType: smithy_client_1.expectString,
        pullRequestId: smithy_client_1.expectString,
        pullRequestMergedStateChangedEventMetadata: smithy_client_1._json,
        pullRequestSourceReferenceUpdatedEventMetadata: smithy_client_1._json,
        pullRequestStatusChangedEventMetadata: smithy_client_1._json,
    });
};
const de_PullRequestEventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PullRequestEvent(entry, context);
    });
    return retVal;
};
const de_RepositoryMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        Arn: smithy_client_1.expectString,
        accountId: smithy_client_1.expectString,
        cloneUrlHttp: smithy_client_1.expectString,
        cloneUrlSsh: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        defaultBranch: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        repositoryDescription: smithy_client_1.expectString,
        repositoryId: smithy_client_1.expectString,
        repositoryName: smithy_client_1.expectString,
    });
};
const de_RepositoryMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RepositoryMetadata(entry, context);
    });
    return retVal;
};
const de_UpdateApprovalRuleTemplateContentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplate: (_) => de_ApprovalRuleTemplate(_, context),
    });
};
const de_UpdateApprovalRuleTemplateDescriptionOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplate: (_) => de_ApprovalRuleTemplate(_, context),
    });
};
const de_UpdateApprovalRuleTemplateNameOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRuleTemplate: (_) => de_ApprovalRuleTemplate(_, context),
    });
};
const de_UpdateCommentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        comment: (_) => de_Comment(_, context),
    });
};
const de_UpdatePullRequestApprovalRuleContentOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approvalRule: (_) => de_ApprovalRule(_, context),
    });
};
const de_UpdatePullRequestDescriptionOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_UpdatePullRequestStatusOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const de_UpdatePullRequestTitleOutput = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        pullRequest: (_) => de_PullRequest(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(CodeCommitServiceException_1.CodeCommitServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `CodeCommit_20150413.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
