{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../lib/modules/versioning/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { SemVer } from 'semver';\nimport type { RangeStrategy } from '../../types';\n\nexport interface NewValueConfig {\n  currentValue: string;\n  rangeStrategy: RangeStrategy;\n  currentVersion?: string;\n  newVersion: string;\n  isReplacement?: boolean;\n}\nexport interface VersioningApi {\n  // validation\n\n  /**\n   * Check whether the `version` is compatible with the `current` value\n   * constraint.\n   */\n  isCompatible(version: string, current?: string): boolean;\n\n  /**\n   * Check whether the `version` constraint is not a range, i.e. it only allows a\n   * single specific version.\n   */\n  isSingleVersion(version: string): boolean;\n\n  /**\n   * Check whether the `version` is considered to be \"stable\".\n   *\n   * Example: in SemVer the version must not have a pre-release marker.\n   */\n  isStable(version: string): boolean;\n\n  /**\n   * Check whether the `input` is a valid version or a valid version range constraint.\n   */\n  isValid(input: string): boolean;\n\n  /**\n   * Check whether the `input` is a valid version string.\n   */\n  isVersion(input: string | undefined | null): boolean;\n\n  // digestion of version\n\n  getMajor(version: string | SemVer): null | number;\n  getMinor(version: string | SemVer): null | number;\n  getPatch(version: string | SemVer): null | number;\n\n  // comparison\n\n  /**\n   * Check whether `version` and `other` are logically equivalent, even if\n   * they're not the exact same string.\n   *\n   * For example, with Semver the build metadata should be ignored when comparing.\n   */\n  equals(version: string, other: string): boolean;\n\n  /**\n   * Check whether `version` is \"greater\" than the `other` version.\n   */\n  isGreaterThan(version: string, other: string): boolean;\n\n  /**\n   * Check whether the `version` is \"less\" than all the versions possible in\n   * the `range`.\n   */\n  isLessThanRange?(version: string, range: string): boolean;\n\n  /**\n   * Select the highest version from `versions` that is within the given\n   * `range` constraint, or return `null` if there is no matching version.\n   */\n  getSatisfyingVersion(versions: string[], range: string): string | null;\n\n  /**\n   * Select the lowest version from `versions` that is within the given\n   * `range` constraint, or return `null` if there is no matching version.\n   */\n  minSatisfyingVersion(versions: string[], range: string): string | null;\n\n  /**\n   * Calculate a new version constraint based on the current constraint, the\n   * `rangeStrategy` option, and the current and new version.\n   */\n  getNewValue(newValueConfig: NewValueConfig): string | null;\n\n  /**\n   * Compare two versions. Return `0` if `v1 == v2`, or `1` if `v1` is\n   * greater, or `-1` if `v2` is greater.\n   */\n  sortVersions(version: string, other: string): number;\n\n  /**\n   * Check whether the `version` satisfies the `range` constraint.\n   */\n  matches(version: string, range: string): boolean;\n\n  valueToVersion?(version: string): string;\n\n  /**\n   * @returns true if subRange is entirely contained by superRange, false otherwise,\n   * and undefined if it cannot determine it.\n   *\n   * @param subRange - the sub range\n   * @param superRange - the dom range\n   */\n  subset?(subRange: string, superRange: string): boolean | undefined;\n\n  /**\n   * Return whether unstable-to-unstable upgrades within the same major version are allowed.\n   */\n  allowUnstableMajorUpgrades?: boolean;\n}\n\nexport interface VersioningApiConstructor {\n  new (config?: string): VersioningApi;\n}\n"]}