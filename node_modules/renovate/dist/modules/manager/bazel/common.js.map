{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../../lib/modules/manager/bazel/common.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAClC,qCAAiC;AAGjC,SAAgB,gBAAgB,CAC9B,KAAa,EACb,IAAkB;IAElB,MAAM,MAAM,GAAG,IAAA,cAAK,EAAC,KAAK,CAAC,CAAC;IAC5B,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,IAAI,CAAC;KACb;IAED,MAAM,CAAC,SAAS,EAAE,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC;IACtC,IAAI,QAAQ,GAAyB,MAAM,CAAC,SAAS,CAAC,CAAC;IACvD,KAAK,IAAI,SAAS,GAAG,CAAC,EAAE,SAAS,GAAG,QAAQ,CAAC,MAAM,EAAE,SAAS,IAAI,CAAC,EAAE;QACnE,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM;SACP;QAED,MAAM,GAAG,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;QAEhC,IAAI,QAAQ,CAAC,IAAI,KAAK,OAAO,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YAC/C,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;SACnC;QAED,IAAI,QAAQ,CAAC,IAAI,KAAK,QAAQ,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YAChD,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;SACnC;KACF;IAED,OAAO,QAAQ,IAAI,IAAI,CAAC;AAC1B,CAAC;AA5BD,4CA4BC;AAED,SAAgB,mBAAmB,CACjC,KAAa,EACb,QAAkB,EAClB,OAAwB;IAExB,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;IACnC,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;IACpC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;IACjD,OAAO,YAAE,CAAC,MAAM,CAAC,OAAO,CAAC;QACvB,CAAC,CAAC,GAAG,IAAI,GAAG,OAAO,GAAG,KAAK,EAAE;QAC7B,CAAC,CAAC,GAAG,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC;AACzC,CAAC;AAXD,kDAWC;AAED,SAAgB,oBAAoB,CAClC,KAAa,EACb,SAAqB,EACrB,OAAwB;IAExB,MAAM,eAAe,GAAG,SAAS,CAAC,IAAI,CACpC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CACxC,CAAC;IACF,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,KAAK,MAAM,QAAQ,IAAI,eAAe,EAAE;QACtC,MAAM,GAAG,mBAAmB,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;KACzD;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAbD,oDAaC;AAED,SAAgB,UAAU,CACxB,KAAa,EACb,IAAkB,EAClB,OAAwB;IAExB,MAAM,QAAQ,GAAG,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IAC/C,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,KAAK,CAAC;KACd;IAED,OAAO,mBAAmB,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACvD,CAAC;AAXD,gCAWC","sourcesContent":["import is from '@sindresorhus/is';\nimport { parse } from './parser';\nimport type { Fragment, FragmentPath, FragmentUpdater } from './types';\n\nexport function findCodeFragment(\n  input: string,\n  path: FragmentPath\n): Fragment | null {\n  const parsed = parse(input);\n  if (!parsed) {\n    return null;\n  }\n\n  const [ruleIndex, ...restPath] = path;\n  let fragment: Fragment | undefined = parsed[ruleIndex];\n  for (let pathIndex = 0; pathIndex < restPath.length; pathIndex += 1) {\n    if (!fragment) {\n      break;\n    }\n\n    const key = restPath[pathIndex];\n\n    if (fragment.type === 'array' && is.number(key)) {\n      fragment = fragment.children[key];\n    }\n\n    if (fragment.type === 'record' && is.string(key)) {\n      fragment = fragment.children[key];\n    }\n  }\n\n  return fragment ?? null;\n}\n\nexport function patchCodeAtFragment(\n  input: string,\n  fragment: Fragment,\n  updater: FragmentUpdater\n): string {\n  const { value, offset } = fragment;\n  const left = input.slice(0, offset);\n  const right = input.slice(offset + value.length);\n  return is.string(updater)\n    ? `${left}${updater}${right}`\n    : `${left}${updater(value)}${right}`;\n}\n\nexport function patchCodeAtFragments(\n  input: string,\n  fragments: Fragment[],\n  updater: FragmentUpdater\n): string {\n  const sortedFragments = fragments.sort(\n    ({ offset: a }, { offset: b }) => b - a\n  );\n  let result = input;\n  for (const fragment of sortedFragments) {\n    result = patchCodeAtFragment(result, fragment, updater);\n  }\n  return result;\n}\n\nexport function updateCode(\n  input: string,\n  path: FragmentPath,\n  updater: FragmentUpdater\n): string {\n  const fragment = findCodeFragment(input, path);\n  if (!fragment) {\n    return input;\n  }\n\n  return patchCodeAtFragment(input, fragment, updater);\n}\n"]}