"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.qDependencies = exports.qLongFormDep = exports.qGroovyMapNotationDependencies = void 0;
const good_enough_parser_1 = require("good-enough-parser");
const regex_1 = require("../../../../util/regex");
const common_1 = require("./common");
const handlers_1 = require("./handlers");
const qGroupId = common_1.qValueMatcher.handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'groupId'));
const qArtifactId = common_1.qValueMatcher.handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'artifactId'));
const qVersion = common_1.qValueMatcher.handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'version'));
// "foo:bar:1.2.3"
// "foo:bar:$baz"
// "foo" + "${bar}" + baz
const qDependencyStrings = common_1.qTemplateString
    .opt(good_enough_parser_1.query.op('+').join(common_1.qValueMatcher))
    .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'templateStringTokens'))
    .handler(handlers_1.handleDepString)
    .handler(common_1.cleanupTempVars);
// dependencySet(group: 'foo', version: bar) { entry 'baz' }
const qDependencySet = good_enough_parser_1.query
    .sym('dependencySet', common_1.storeVarToken)
    .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'methodName'))
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query
        .begin()
        .sym('group')
        .alt(good_enough_parser_1.query.op(':'), good_enough_parser_1.query.op('='))
        .join(qGroupId)
        .op(',')
        .sym('version')
        .alt(good_enough_parser_1.query.op(':'), good_enough_parser_1.query.op('='))
        .join(qVersion)
        .end(),
})
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '{',
    endsWith: '}',
    search: good_enough_parser_1.query
        .sym('entry')
        .alt(qArtifactId, good_enough_parser_1.query.tree({
        type: 'wrapped-tree',
        maxDepth: 1,
        startsWith: '(',
        endsWith: ')',
        search: good_enough_parser_1.query.begin().join(qArtifactId).end(),
    }))
        .handler(handlers_1.handleLongFormDep),
})
    .handler(common_1.cleanupTempVars);
// group: "foo", name: "bar", version: "1.2.3"
exports.qGroovyMapNotationDependencies = good_enough_parser_1.query
    .sym('group')
    .op(':')
    .join(qGroupId)
    .op(',')
    .sym('name')
    .op(':')
    .join(qArtifactId)
    .op(',')
    .sym('version')
    .op(':')
    .join(qVersion)
    .handler(handlers_1.handleLongFormDep)
    .handler(common_1.cleanupTempVars);
// kotlin("bom", "1.7.21")
const qKotlinShortNotationDependencies = good_enough_parser_1.query
    .sym('kotlin')
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query
        .begin()
        .join(qArtifactId)
        .op(',')
        .opt(good_enough_parser_1.query.sym('version').op('='))
        .join(qVersion)
        .end(),
})
    .handler(handlers_1.handleKotlinShortNotationDep)
    .handler(common_1.cleanupTempVars);
// (group = "foo", name = "bar", version = "1.2.3")
const qKotlinMapNotationDependencies = good_enough_parser_1.query
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query
        .begin()
        .sym('group')
        .op('=')
        .join(qGroupId)
        .op(',')
        .sym('name')
        .op('=')
        .join(qArtifactId)
        .op(',')
        .sym('version')
        .op('=')
        .join(qVersion),
})
    .handler(handlers_1.handleLongFormDep)
    .handler(common_1.cleanupTempVars);
// someMethod("foo", "bar", "1.2.3")
exports.qLongFormDep = good_enough_parser_1.query
    .opt(good_enough_parser_1.query.sym(common_1.storeVarToken).handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'methodName')))
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    maxMatches: 1,
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query
        .begin()
        .join(qGroupId)
        .op(',')
        .join(qArtifactId)
        .op(',')
        .join(qVersion)
        .end(),
})
    .handler(handlers_1.handleLongFormDep)
    .handler(common_1.cleanupTempVars);
// pmd { toolVersion = "1.2.3" }
const qImplicitGradlePlugin = good_enough_parser_1.query
    .alt(...Object.keys(common_1.GRADLE_PLUGINS).map((pluginName) => good_enough_parser_1.query
    .sym(pluginName, common_1.storeVarToken)
    .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'pluginName'))
    .tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    maxMatches: 1,
    startsWith: '{',
    endsWith: '}',
    search: good_enough_parser_1.query
        .sym(common_1.GRADLE_PLUGINS[pluginName][0])
        .alt(
    // toolVersion = "1.2.3"
    good_enough_parser_1.query.opt(good_enough_parser_1.query.op('=')).join(qVersion), 
    // toolVersion.set("1.2.3"), toolVersion.value("1.2.3")
    good_enough_parser_1.query
        .op('.')
        .sym((0, regex_1.regEx)(/^(?:set|value)$/))
        .tree({
        maxDepth: 1,
        startsWith: '(',
        endsWith: ')',
        search: good_enough_parser_1.query.begin().join(qVersion).end(),
    })),
})))
    .handler(handlers_1.handleImplicitGradlePlugin)
    .handler(common_1.cleanupTempVars);
exports.qDependencies = good_enough_parser_1.query.alt(qDependencyStrings, qDependencySet, exports.qGroovyMapNotationDependencies, qKotlinShortNotationDependencies, qKotlinMapNotationDependencies, qImplicitGradlePlugin);
//# sourceMappingURL=dependencies.js.map