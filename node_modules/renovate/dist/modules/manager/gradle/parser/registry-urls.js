"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.qRegistryUrls = void 0;
const good_enough_parser_1 = require("good-enough-parser");
const regex_1 = require("../../../../util/regex");
const apply_from_1 = require("./apply-from");
const assignments_1 = require("./assignments");
const common_1 = require("./common");
const handlers_1 = require("./handlers");
const plugins_1 = require("./plugins");
// uri("https://foo.bar/baz")
// "https://foo.bar/baz"
const qUri = good_enough_parser_1.query
    .alt(good_enough_parser_1.query.sym('uri').tree({
    maxDepth: 1,
    search: common_1.qValueMatcher,
}), common_1.qValueMatcher)
    .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'registryUrl'));
// mavenCentral()
// mavenCentral { ... }
const qPredefinedRegistries = good_enough_parser_1.query
    .sym((0, regex_1.regEx)(`^(?:${Object.keys(common_1.REGISTRY_URLS).join('|')})$`), common_1.storeVarToken)
    .alt(good_enough_parser_1.query.tree({
    type: 'wrapped-tree',
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query.begin().end(),
}), good_enough_parser_1.query.tree({
    type: 'wrapped-tree',
    startsWith: '{',
    endsWith: '}',
}))
    .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'registryUrl'))
    .handler(handlers_1.handlePredefinedRegistryUrl)
    .handler(common_1.cleanupTempVars);
// maven(url = uri("https://foo.bar/baz"))
// maven { name = some; url = "https://foo.bar/${name}" }
const qCustomRegistryUrl = good_enough_parser_1.query
    .sym('maven')
    .alt(good_enough_parser_1.query.tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '(',
    endsWith: ')',
    search: good_enough_parser_1.query.begin().opt(good_enough_parser_1.query.sym('url').op('=')).join(qUri).end(),
}), good_enough_parser_1.query.tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    startsWith: '{',
    endsWith: '}',
    search: good_enough_parser_1.query.alt(good_enough_parser_1.query
        .sym('name')
        .opt(good_enough_parser_1.query.op('='))
        .join(common_1.qValueMatcher)
        .handler((ctx) => (0, common_1.storeInTokenMap)(ctx, 'name')), good_enough_parser_1.query.sym('url').opt(good_enough_parser_1.query.op('=')).join(qUri), good_enough_parser_1.query.sym('setUrl').tree({
        maxDepth: 1,
        startsWith: '(',
        endsWith: ')',
        search: good_enough_parser_1.query.begin().join(qUri).end(),
    })),
}))
    .handler(handlers_1.handleCustomRegistryUrl)
    .handler(common_1.cleanupTempVars);
const qPluginManagement = good_enough_parser_1.query.sym('pluginManagement', common_1.storeVarToken).tree({
    type: 'wrapped-tree',
    startsWith: '{',
    endsWith: '}',
    preHandler: (ctx) => {
        ctx.tmpTokenStore.registryScope = ctx.varTokens;
        ctx.varTokens = [];
        return ctx;
    },
    search: good_enough_parser_1.query
        .handler((ctx) => {
        if (ctx.tmpTokenStore.registryScope) {
            ctx.tokenMap.registryScope = ctx.tmpTokenStore.registryScope;
        }
        return ctx;
    })
        .alt(assignments_1.qAssignments, apply_from_1.qApplyFrom, plugins_1.qPlugins, qPredefinedRegistries, qCustomRegistryUrl),
    postHandler: (ctx) => {
        delete ctx.tmpTokenStore.registryScope;
        return ctx;
    },
});
exports.qRegistryUrls = good_enough_parser_1.query.alt(good_enough_parser_1.query.sym('publishing').tree(), qPluginManagement, qPredefinedRegistries, qCustomRegistryUrl);
//# sourceMappingURL=registry-urls.js.map