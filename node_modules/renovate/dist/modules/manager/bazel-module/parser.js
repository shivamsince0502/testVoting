"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const tslib_1 = require("tslib");
const good_enough_parser_1 = require("good-enough-parser");
const regex_1 = require("../../../util/regex");
const context_1 = require("./context");
const starlark = tslib_1.__importStar(require("./starlark"));
const booleanValuesRegex = (0, regex_1.regEx)(`^${starlark.booleanStringValues.join('|')}$`);
const supportedRules = [
    'archive_override',
    'bazel_dep',
    'git_override',
    'local_path_override',
    'single_version_override',
];
const supportedRulesRegex = (0, regex_1.regEx)(`^${supportedRules.join('|')}$`);
/**
 * Matches key-value pairs:
 * - `name = "foobar"`
 **/
const kvParams = good_enough_parser_1.query
    .sym((ctx, token) => ctx.startAttribute(token.value))
    .op('=')
    .alt(good_enough_parser_1.query.str((ctx, token) => ctx.addString(token.value)), good_enough_parser_1.query.sym(booleanValuesRegex, (ctx, token) => ctx.addBoolean(token.value)));
const moduleRules = good_enough_parser_1.query
    .sym(supportedRulesRegex, (ctx, token) => ctx.startRule(token.value))
    .join(good_enough_parser_1.query.tree({
    type: 'wrapped-tree',
    maxDepth: 1,
    search: kvParams,
    postHandler: (ctx, tree) => ctx.endRule(),
}));
const rule = good_enough_parser_1.query.alt(moduleRules);
const query = good_enough_parser_1.query.tree({
    type: 'root-tree',
    maxDepth: 16,
    search: rule,
});
const starlarkLang = good_enough_parser_1.lang.createLang('starlark');
function parse(input) {
    const parsedResult = starlarkLang.query(input, query, new context_1.Ctx());
    return parsedResult?.results ?? [];
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map