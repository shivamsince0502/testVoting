"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ctx = exports.CtxProcessingError = void 0;
const tslib_1 = require("tslib");
const fragments = tslib_1.__importStar(require("./fragments"));
class CtxProcessingError extends Error {
    current;
    parent;
    constructor(current, parent) {
        const msg = `Invalid context state. current: ${current.type}, parent: ${parent?.type ?? 'none'}`;
        super(msg);
        this.name = 'CtxProcessingError';
        this.current = current;
        this.parent = parent;
    }
}
exports.CtxProcessingError = CtxProcessingError;
class Ctx {
    results;
    stack;
    constructor(results = [], stack = []) {
        this.results = results;
        this.stack = stack;
    }
    get safeCurrent() {
        return this.stack.at(-1);
    }
    get current() {
        const c = this.safeCurrent;
        if (c === undefined) {
            throw new Error('Requested current, but no value.');
        }
        return c;
    }
    get currentRecord() {
        const current = this.current;
        if (current.type === 'record') {
            return current;
        }
        throw new Error('Requested current record, but does not exist.');
    }
    get currentArray() {
        const current = this.current;
        if (current.type === 'array') {
            return current;
        }
        throw new Error('Requested current array, but does not exist.');
    }
    popStack() {
        const current = this.stack.pop();
        if (!current) {
            return false;
        }
        if (!current.isComplete) {
            this.stack.push(current);
            return false;
        }
        const parent = this.safeCurrent;
        if (parent) {
            if (parent.type === 'attribute' && fragments.isValue(current)) {
                parent.value = current;
                parent.isComplete = true;
                return true;
            }
            if (parent.type === 'array' && fragments.isPrimitive(current)) {
                parent.items.push(current);
                return true;
            }
            if (parent.type === 'record' &&
                current.type === 'attribute' &&
                current.value !== undefined) {
                parent.children[current.name] = current.value;
                return true;
            }
        }
        else if (current.type === 'record') {
            this.results.push(current);
            return true;
        }
        throw new CtxProcessingError(current, parent);
    }
    processStack() {
        while (this.popStack()) {
            // Nothing to do
        }
        return this;
    }
    addString(value) {
        this.stack.push(fragments.string(value));
        return this.processStack();
    }
    addBoolean(value) {
        this.stack.push(fragments.boolean(value));
        return this.processStack();
    }
    startRecord(children = {}) {
        const record = fragments.record(children);
        this.stack.push(record);
        return this;
    }
    endRecord() {
        const record = this.currentRecord;
        record.isComplete = true;
        return this.processStack();
    }
    startRule(name) {
        return this.startRecord({ rule: fragments.string(name) });
    }
    endRule() {
        return this.endRecord();
    }
    startAttribute(name) {
        this.stack.push(fragments.attribute(name));
        return this.processStack();
    }
    startArray() {
        this.stack.push(fragments.array());
        return this.processStack();
    }
    endArray() {
        const array = this.currentArray;
        array.isComplete = true;
        return this.processStack();
    }
}
exports.Ctx = Ctx;
//# sourceMappingURL=context.js.map