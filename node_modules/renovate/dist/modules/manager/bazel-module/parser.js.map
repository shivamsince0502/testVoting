{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../../lib/modules/manager/bazel-module/parser.ts"],"names":[],"mappings":";;;;AAAA,2DAAsD;AACtD,+CAA4C;AAC5C,uCAAgC;AAEhC,6DAAuC;AAEvC,MAAM,kBAAkB,GAAG,IAAA,aAAK,EAAC,IAAI,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAChF,MAAM,cAAc,GAAG;IACrB,kBAAkB;IAClB,WAAW;IACX,cAAc;IACd,qBAAqB;IACrB,yBAAyB;CAC1B,CAAC;AACF,MAAM,mBAAmB,GAAG,IAAA,aAAK,EAAC,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAEnE;;;IAGI;AACJ,MAAM,QAAQ,GAAG,0BAAC;KACf,GAAG,CAAM,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KACzD,EAAE,CAAC,GAAG,CAAC;KACP,GAAG,CACF,0BAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EACjD,0BAAC,CAAC,GAAG,CAAM,kBAAkB,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAC5E,CAAC;AAEJ,MAAM,WAAW,GAAG,0BAAC;KAClB,GAAG,CAAM,mBAAmB,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KACzE,IAAI,CACH,0BAAC,CAAC,IAAI,CAAC;IACL,IAAI,EAAE,cAAc;IACpB,QAAQ,EAAE,CAAC;IACX,MAAM,EAAE,QAAQ;IAChB,WAAW,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,EAAE;CAC1C,CAAC,CACH,CAAC;AAEJ,MAAM,IAAI,GAAG,0BAAC,CAAC,GAAG,CAAM,WAAW,CAAC,CAAC;AAErC,MAAM,KAAK,GAAG,0BAAC,CAAC,IAAI,CAAM;IACxB,IAAI,EAAE,WAAW;IACjB,QAAQ,EAAE,EAAE;IACZ,MAAM,EAAE,IAAI;CACb,CAAC,CAAC;AAEH,MAAM,YAAY,GAAG,yBAAI,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAEjD,SAAgB,KAAK,CAAC,KAAa;IACjC,MAAM,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,aAAG,EAAE,CAAC,CAAC;IACjE,OAAO,YAAY,EAAE,OAAO,IAAI,EAAE,CAAC;AACrC,CAAC;AAHD,sBAGC","sourcesContent":["import { lang, query as q } from 'good-enough-parser';\nimport { regEx } from '../../../util/regex';\nimport { Ctx } from './context';\nimport type { RecordFragment } from './fragments';\nimport * as starlark from './starlark';\n\nconst booleanValuesRegex = regEx(`^${starlark.booleanStringValues.join('|')}$`);\nconst supportedRules = [\n  'archive_override',\n  'bazel_dep',\n  'git_override',\n  'local_path_override',\n  'single_version_override',\n];\nconst supportedRulesRegex = regEx(`^${supportedRules.join('|')}$`);\n\n/**\n * Matches key-value pairs:\n * - `name = \"foobar\"`\n **/\nconst kvParams = q\n  .sym<Ctx>((ctx, token) => ctx.startAttribute(token.value))\n  .op('=')\n  .alt(\n    q.str((ctx, token) => ctx.addString(token.value)),\n    q.sym<Ctx>(booleanValuesRegex, (ctx, token) => ctx.addBoolean(token.value))\n  );\n\nconst moduleRules = q\n  .sym<Ctx>(supportedRulesRegex, (ctx, token) => ctx.startRule(token.value))\n  .join(\n    q.tree({\n      type: 'wrapped-tree',\n      maxDepth: 1,\n      search: kvParams,\n      postHandler: (ctx, tree) => ctx.endRule(),\n    })\n  );\n\nconst rule = q.alt<Ctx>(moduleRules);\n\nconst query = q.tree<Ctx>({\n  type: 'root-tree',\n  maxDepth: 16,\n  search: rule,\n});\n\nconst starlarkLang = lang.createLang('starlark');\n\nexport function parse(input: string): RecordFragment[] {\n  const parsedResult = starlarkLang.query(input, query, new Ctx());\n  return parsedResult?.results ?? [];\n}\n"]}