"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePyProject = exports.parseDependencyList = exports.parseDependencyGroupRecord = exports.pep508ToPackageDependency = exports.parsePEP508 = exports.depTypes = void 0;
const tslib_1 = require("tslib");
const toml_1 = tslib_1.__importDefault(require("@iarna/toml"));
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const logger_1 = require("../../../logger");
const regex_1 = require("../../../util/regex");
const pypi_1 = require("../../datasource/pypi");
const schema_1 = require("./schema");
const pep508Regex = (0, regex_1.regEx)(/^(?<packageName>[A-Z0-9._-]+)\s*(\[(?<extras>[A-Z0-9,._-]+)\])?\s*(?<currentValue>[^;]+)?(;\s*(?<marker>.*))?/i);
exports.depTypes = {
    dependencies: 'project.dependencies',
    optionalDependencies: 'project.optional-dependencies',
    pdmDevDependencies: 'tool.pdm.dev-dependencies',
};
function parsePEP508(value) {
    if (is_1.default.nullOrUndefined(value)) {
        return null;
    }
    const regExpExec = pep508Regex.exec(value);
    if (is_1.default.nullOrUndefined(regExpExec) ||
        is_1.default.nullOrUndefined(regExpExec?.groups)) {
        logger_1.logger.trace(`Pep508 could not be extracted`);
        return null;
    }
    const result = {
        packageName: regExpExec.groups.packageName,
    };
    if (is_1.default.nonEmptyString(regExpExec.groups.currentValue)) {
        result.currentValue = regExpExec.groups.currentValue;
    }
    if (is_1.default.nonEmptyString(regExpExec.groups.marker)) {
        result.marker = regExpExec.groups.marker;
    }
    if (is_1.default.nonEmptyString(regExpExec.groups.extras)) {
        result.extras = regExpExec.groups.extras.split(',');
    }
    return result;
}
exports.parsePEP508 = parsePEP508;
function pep508ToPackageDependency(depType, value) {
    const parsed = parsePEP508(value);
    if (is_1.default.nullOrUndefined(parsed)) {
        return null;
    }
    const dep = {
        packageName: parsed.packageName,
        depName: parsed.packageName,
        datasource: pypi_1.PypiDatasource.id,
        depType,
    };
    if (is_1.default.nullOrUndefined(parsed.currentValue)) {
        dep.skipReason = 'unspecified-version';
    }
    else {
        dep.currentValue = parsed.currentValue;
    }
    return dep;
}
exports.pep508ToPackageDependency = pep508ToPackageDependency;
function parseDependencyGroupRecord(depType, records) {
    if (is_1.default.nullOrUndefined(records)) {
        return [];
    }
    const deps = [];
    for (const [groupName, pep508Strings] of Object.entries(records)) {
        for (const dep of parseDependencyList(depType, pep508Strings)) {
            deps.push({ ...dep, depName: `${groupName}/${dep.packageName}` });
        }
    }
    return deps;
}
exports.parseDependencyGroupRecord = parseDependencyGroupRecord;
function parseDependencyList(depType, list) {
    if (is_1.default.nullOrUndefined(list)) {
        return [];
    }
    const deps = [];
    for (const element of list) {
        const dep = pep508ToPackageDependency(depType, element);
        if (is_1.default.truthy(dep)) {
            deps.push(dep);
        }
    }
    return deps;
}
exports.parseDependencyList = parseDependencyList;
function parsePyProject(packageFile, content) {
    try {
        const jsonMap = toml_1.default.parse(content);
        return schema_1.PyProjectSchema.parse(jsonMap);
    }
    catch (err) {
        logger_1.logger.debug({ packageFile, err }, `Failed to parse and validate pyproject file`);
        return null;
    }
}
exports.parsePyProject = parsePyProject;
//# sourceMappingURL=utils.js.map