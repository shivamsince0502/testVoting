"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackageFile = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const js_yaml_1 = require("js-yaml");
const logger_1 = require("../../../logger");
const array_1 = require("../../../util/array");
const url_1 = require("../../../util/url");
const docker_1 = require("../../datasource/docker");
const git_tags_1 = require("../../datasource/git-tags");
const helm_1 = require("../../datasource/helm");
const util_1 = require("./util");
function extractPackageFile(content, packageFile, _config) {
    // check for argo reference. API version for the kind attribute is used
    if (util_1.fileTestRegex.test(content) === false) {
        return null;
    }
    let definitions;
    try {
        definitions = (0, js_yaml_1.loadAll)(content);
    }
    catch (err) {
        logger_1.logger.debug({ err, packageFile }, 'Failed to parse ArgoCD definition.');
        return null;
    }
    const deps = definitions.filter(is_1.default.plainObject).flatMap(processAppSpec);
    return deps.length ? { deps } : null;
}
exports.extractPackageFile = extractPackageFile;
function processSource(source) {
    if (!source ||
        !is_1.default.nonEmptyString(source.repoURL) ||
        !is_1.default.nonEmptyString(source.targetRevision)) {
        return null;
    }
    // a chart variable is defined this is helm declaration
    if (source.chart) {
        // assume OCI helm chart if repoURL doesn't contain explicit protocol
        if (source.repoURL.startsWith('oci://') ||
            !source.repoURL.includes('://')) {
            let registryURL = source.repoURL.replace('oci://', '');
            registryURL = (0, url_1.trimTrailingSlash)(registryURL);
            return {
                depName: `${registryURL}/${source.chart}`,
                currentValue: source.targetRevision,
                datasource: docker_1.DockerDatasource.id,
            };
        }
        return {
            depName: source.chart,
            registryUrls: [source.repoURL],
            currentValue: source.targetRevision,
            datasource: helm_1.HelmDatasource.id,
        };
    }
    return {
        depName: source.repoURL,
        currentValue: source.targetRevision,
        datasource: git_tags_1.GitTagsDatasource.id,
    };
}
function processAppSpec(definition) {
    const spec = definition.kind === 'Application'
        ? definition?.spec
        : definition?.spec?.template?.spec;
    if (is_1.default.nullOrUndefined(spec)) {
        return [];
    }
    const deps = [];
    if (is_1.default.nonEmptyObject(spec.source)) {
        deps.push(processSource(spec.source));
    }
    for (const source of (0, array_1.coerceArray)(spec.sources)) {
        deps.push(processSource(source));
    }
    return deps.filter(is_1.default.truthy);
}
//# sourceMappingURL=extract.js.map