"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArtifactAuthEnabled = exports.takePersonalAccessTokenIfPossible = exports.isGithubFineGrainedPersonalAccessToken = exports.isGithubServerToServerToken = exports.isGithubPersonalAccessToken = exports.findGithubToken = exports.extractConstraints = exports.requireComposerDependencyInstallation = exports.getPhpConstraint = exports.getComposerArguments = exports.composerVersioningId = void 0;
// TODO: types (#7154)
/* eslint-disable @typescript-eslint/restrict-template-expressions */
const shlex_1 = require("shlex");
const global_1 = require("../../../config/global");
const logger_1 = require("../../../logger");
const composer_1 = require("../../versioning/composer");
Object.defineProperty(exports, "composerVersioningId", { enumerable: true, get: function () { return composer_1.id; } });
const depRequireInstall = new Set(['symfony/flex']);
function getComposerArguments(config, toolConstraint) {
    let args = '';
    if (config.composerIgnorePlatformReqs) {
        if (config.composerIgnorePlatformReqs.length === 0) {
            // TODO: toolConstraint.constraint can be null or undefined? (#7154)
            const major = composer_1.api.getMajor(toolConstraint.constraint);
            const minor = composer_1.api.getMinor(toolConstraint.constraint);
            args += composer_1.api.matches(`${major}.${minor}`, '^2.2')
                ? " --ignore-platform-req='ext-*' --ignore-platform-req='lib-*'"
                : ' --ignore-platform-reqs';
        }
        else {
            config.composerIgnorePlatformReqs.forEach((req) => {
                args += ' --ignore-platform-req ' + (0, shlex_1.quote)(req);
            });
        }
    }
    args += ' --no-ansi --no-interaction';
    if (!global_1.GlobalConfig.get('allowScripts') || config.ignoreScripts) {
        args += ' --no-scripts --no-autoloader';
    }
    if (!global_1.GlobalConfig.get('allowPlugins') || config.ignorePlugins) {
        args += ' --no-plugins';
    }
    return args;
}
exports.getComposerArguments = getComposerArguments;
function getPhpConstraint(constraints) {
    const { php } = constraints;
    if (php) {
        logger_1.logger.debug('Using php constraint from config');
        return php;
    }
    return null;
}
exports.getPhpConstraint = getPhpConstraint;
function requireComposerDependencyInstallation({ packages, packagesDev, }) {
    return (packages.some((p) => depRequireInstall.has(p.name)) === true ||
        packagesDev.some((p) => depRequireInstall.has(p.name)) === true);
}
exports.requireComposerDependencyInstallation = requireComposerDependencyInstallation;
function extractConstraints({ config, require, requireDev }, { pluginApiVersion }) {
    const res = { composer: '1.*' };
    // extract php
    const phpVersion = config?.platform.php;
    if (phpVersion) {
        const major = composer_1.api.getMajor(phpVersion);
        const minor = composer_1.api.getMinor(phpVersion) ?? 0;
        const patch = composer_1.api.getPatch(phpVersion) ?? 0;
        res.php = `<=${major}.${minor}.${patch}`;
    }
    else if (require.php) {
        res.php = require.php;
    }
    // extract direct composer dependency
    if (require['composer/composer']) {
        res.composer = require['composer/composer'];
    }
    else if (requireDev['composer/composer']) {
        res.composer = requireDev['composer/composer'];
    }
    // composer platform package
    else if (require['composer']) {
        res.composer = require['composer'];
    }
    else if (requireDev['composer']) {
        res.composer = requireDev['composer'];
    }
    // check last used composer version
    else if (pluginApiVersion) {
        const major = composer_1.api.getMajor(pluginApiVersion);
        const minor = composer_1.api.getMinor(pluginApiVersion);
        res.composer = `^${major}.${minor}`;
    }
    // check composer api dependency
    else if (require['composer-runtime-api']) {
        const major = composer_1.api.getMajor(require['composer-runtime-api']);
        const minor = composer_1.api.getMinor(require['composer-runtime-api']);
        res.composer = `^${major}.${minor}`;
    }
    return res;
}
exports.extractConstraints = extractConstraints;
function findGithubToken(searchResult) {
    return searchResult?.token?.replace('x-access-token:', '');
}
exports.findGithubToken = findGithubToken;
function isGithubPersonalAccessToken(token) {
    return token.startsWith('ghp_');
}
exports.isGithubPersonalAccessToken = isGithubPersonalAccessToken;
function isGithubServerToServerToken(token) {
    return token.startsWith('ghs_');
}
exports.isGithubServerToServerToken = isGithubServerToServerToken;
function isGithubFineGrainedPersonalAccessToken(token) {
    return token.startsWith('github_pat_');
}
exports.isGithubFineGrainedPersonalAccessToken = isGithubFineGrainedPersonalAccessToken;
function takePersonalAccessTokenIfPossible(githubToken, gitTagsGithubToken) {
    if (gitTagsGithubToken && isGithubPersonalAccessToken(gitTagsGithubToken)) {
        logger_1.logger.debug('Using GitHub Personal Access Token (git-tags)');
        return gitTagsGithubToken;
    }
    if (githubToken && isGithubPersonalAccessToken(githubToken)) {
        logger_1.logger.debug('Using GitHub Personal Access Token');
        return githubToken;
    }
    if (gitTagsGithubToken &&
        isGithubFineGrainedPersonalAccessToken(gitTagsGithubToken)) {
        logger_1.logger.debug('Using GitHub Fine-grained Personal Access Token (git-tags)');
        return gitTagsGithubToken;
    }
    if (githubToken && isGithubFineGrainedPersonalAccessToken(githubToken)) {
        logger_1.logger.debug('Using GitHub Fine-grained Personal Access Token');
        return githubToken;
    }
    if (gitTagsGithubToken) {
        if (isGithubServerToServerToken(gitTagsGithubToken)) {
            logger_1.logger.debug('Using GitHub Server-to-Server token (git-tags)');
        }
        else {
            logger_1.logger.debug('Using unknown GitHub token type (git-tags)');
        }
        return gitTagsGithubToken;
    }
    if (githubToken) {
        if (isGithubServerToServerToken(githubToken)) {
            logger_1.logger.debug('Using GitHub Server-to-Server token');
        }
        else {
            logger_1.logger.debug('Using unknown GitHub token type');
        }
    }
    return githubToken;
}
exports.takePersonalAccessTokenIfPossible = takePersonalAccessTokenIfPossible;
function isArtifactAuthEnabled(rule) {
    return !rule.artifactAuth || rule.artifactAuth.includes('composer');
}
exports.isArtifactAuthEnabled = isArtifactAuthEnabled;
//# sourceMappingURL=utils.js.map