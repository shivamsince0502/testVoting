"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConstraintFromLockFile = exports.getPnpmConstraintFromPackageFile = exports.generateLockFile = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const js_yaml_1 = require("js-yaml");
const upath_1 = tslib_1.__importDefault(require("upath"));
const global_1 = require("../../../../config/global");
const error_messages_1 = require("../../../../constants/error-messages");
const logger_1 = require("../../../../logger");
const exec_1 = require("../../../../util/exec");
const fs_1 = require("../../../../util/fs");
const node_version_1 = require("./node-version");
function getPnpmConstraintFromUpgrades(upgrades) {
    for (const upgrade of upgrades) {
        if (upgrade.depName === 'pnpm' && upgrade.newVersion) {
            return upgrade.newVersion;
        }
    }
    return null;
}
async function generateLockFile(lockFileDir, env, config, upgrades = []) {
    const lockFileName = upath_1.default.join(lockFileDir, 'pnpm-lock.yaml');
    logger_1.logger.debug(`Spawning pnpm install to create ${lockFileName}`);
    let lockFile = null;
    let stdout;
    let stderr;
    let cmd = 'pnpm';
    try {
        const pnpmToolConstraint = {
            toolName: 'pnpm',
            constraint: getPnpmConstraintFromUpgrades(upgrades) ?? // if pnpm is being upgraded, it comes first
                config.constraints?.pnpm ?? // from user config or extraction
                (await getPnpmConstraintFromPackageFile(lockFileDir)) ?? // look in package.json > packageManager or engines
                (await getConstraintFromLockFile(lockFileName)), // use lockfileVersion to find pnpm version range
        };
        const extraEnv = {
            NPM_CONFIG_CACHE: env.NPM_CONFIG_CACHE,
            npm_config_store: env.npm_config_store,
        };
        const execOptions = {
            cwdFile: lockFileName,
            extraEnv,
            docker: {},
            toolConstraints: [
                await (0, node_version_1.getNodeToolConstraint)(config, upgrades, lockFileDir),
                pnpmToolConstraint,
            ],
        };
        // istanbul ignore if
        if (global_1.GlobalConfig.get('exposeAllEnv')) {
            extraEnv.NPM_AUTH = env.NPM_AUTH;
            extraEnv.NPM_EMAIL = env.NPM_EMAIL;
        }
        const commands = [];
        cmd = 'pnpm';
        let args = 'install --recursive --lockfile-only';
        if (!global_1.GlobalConfig.get('allowScripts') || config.ignoreScripts) {
            args += ' --ignore-scripts';
            args += ' --ignore-pnpmfile';
        }
        logger_1.logger.trace({ cmd, args }, 'pnpm command');
        commands.push(`${cmd} ${args}`);
        // postUpdateOptions
        if (config.postUpdateOptions?.includes('pnpmDedupe')) {
            logger_1.logger.debug('Performing pnpm dedupe');
            commands.push('pnpm dedupe');
        }
        if (upgrades.find((upgrade) => upgrade.isLockFileMaintenance)) {
            logger_1.logger.debug(`Removing ${lockFileName} first due to lock file maintenance upgrade`);
            try {
                await (0, fs_1.deleteLocalFile)(lockFileName);
            }
            catch (err) /* istanbul ignore next */ {
                logger_1.logger.debug({ err, lockFileName }, 'Error removing yarn.lock for lock file maintenance');
            }
        }
        await (0, exec_1.exec)(commands, execOptions);
        lockFile = await (0, fs_1.readLocalFile)(lockFileName, 'utf8');
    }
    catch (err) /* istanbul ignore next */ {
        if (err.message === error_messages_1.TEMPORARY_ERROR) {
            throw err;
        }
        logger_1.logger.debug({
            cmd,
            err,
            stdout,
            stderr,
            type: 'pnpm',
        }, 'lock file error');
        return { error: true, stderr: err.stderr, stdout: err.stdout };
    }
    return { lockFile };
}
exports.generateLockFile = generateLockFile;
async function getPnpmConstraintFromPackageFile(lockFileDir) {
    let constraint;
    const rootPackageJson = upath_1.default.join(lockFileDir, 'package.json');
    const content = await (0, fs_1.readLocalFile)(rootPackageJson, 'utf8');
    if (content) {
        const packageJson = JSON.parse(content);
        const packageManager = packageJson?.packageManager;
        if (packageManager?.includes('@')) {
            const nameAndVersion = packageManager.split('@');
            const name = nameAndVersion[0];
            if (name === 'pnpm') {
                constraint = nameAndVersion[1];
            }
        }
        else {
            const engines = packageJson?.engines;
            if (engines) {
                constraint = engines['pnpm'];
            }
        }
    }
    return constraint;
}
exports.getPnpmConstraintFromPackageFile = getPnpmConstraintFromPackageFile;
async function getConstraintFromLockFile(lockFileName) {
    let constraint = null;
    try {
        const lockfileContent = await (0, fs_1.readLocalFile)(lockFileName, 'utf8');
        if (!lockfileContent) {
            return null;
        }
        const pnpmLock = (0, js_yaml_1.load)(lockfileContent);
        if (!is_1.default.number(pnpmLock?.lockfileVersion)) {
            return null;
        }
        // find matching lockfileVersion and use its constraints
        // if no match found use lockfileVersion 5
        // lockfileVersion 5 is the minimum version required to generate the pnpm-lock.yaml file
        const { lowerConstraint, upperConstraint } = lockToPnpmVersionMapping.find((m) => m.lockfileVersion === pnpmLock.lockfileVersion) ?? {
            lockfileVersion: 5.0,
            lowerConstraint: '>=3',
            upperConstraint: '<3.5.0',
        };
        constraint = lowerConstraint;
        if (upperConstraint) {
            constraint += ` ${upperConstraint}`;
        }
    }
    catch (err) {
        logger_1.logger.warn({ err }, 'Error getting pnpm constraints from lock file');
    }
    return constraint;
}
exports.getConstraintFromLockFile = getConstraintFromLockFile;
/**
 pnpm lockfiles have corresponding version numbers called "lockfileVersion"
 each lockfileVersion can only be generated by a certain pnpm version ranges
 eg. lockfileVersion: 5.4 can only be generated by pnpm version >=7 && <8
 official list can be found here : https://github.com/pnpm/spec/tree/master/lockfile
 we use the mapping present below to find the compatible pnpm version range for a given lockfileVersion

 the various terms used in the mapping are explained below:
 lowerConstriant : lowest pnpm version that can generate the lockfileVersion
 upperConstraint : highest pnpm version that can generate the lockfileVersion
 lowerBound      : highest pnpm version that is less than the lowerConstraint
 upperBound      : lowest pnpm version that is greater than upperConstraint

 For handling future lockfileVersions, we need to:
 1. add a upperBound and upperConstraint to the current lastest lockfileVersion
 2. add an object for the new lockfileVersion with lowerBound and lowerConstraint
 */
const lockToPnpmVersionMapping = [
    { lockfileVersion: 6.0, lowerConstraint: '>=7.24.2' },
    {
        lockfileVersion: 5.4,
        lowerConstraint: '>=7',
        upperConstraint: '<8',
    },
    {
        lockfileVersion: 5.3,
        lowerConstraint: '>=6',
        upperConstraint: '<7',
    },
    {
        lockfileVersion: 5.2,
        lowerConstraint: '>=5.10.0',
        upperConstraint: '<6',
    },
    {
        lockfileVersion: 5.1,
        lowerConstraint: '>=3.5.0',
        upperConstraint: '<5.9.3',
    },
];
//# sourceMappingURL=pnpm.js.map