"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFileInDir = exports.aliasRecordToRepositories = exports.isOCIRegistry = exports.isAlias = exports.getRepositories = exports.resolveAlias = exports.parseRepository = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const upath_1 = tslib_1.__importDefault(require("upath"));
const logger_1 = require("../../../logger");
const docker_1 = require("../../datasource/docker");
function parseRepository(depName, repositoryURL) {
    const res = {};
    try {
        const url = new URL(repositoryURL);
        switch (url.protocol) {
            case 'oci:':
                res.datasource = docker_1.DockerDatasource.id;
                res.packageName = `${repositoryURL.replace('oci://', '')}/${depName}`;
                break;
            case 'file:':
                res.skipReason = 'local-dependency';
                break;
            default:
                res.registryUrls = [repositoryURL];
        }
    }
    catch (err) {
        logger_1.logger.debug({ err }, 'Error parsing url');
        res.skipReason = 'invalid-url';
    }
    return res;
}
exports.parseRepository = parseRepository;
/**
 * Resolves alias in repository string.
 *
 * @param repository to be resolved string
 * @param registryAliases Records containing registryAliases as key and to be resolved URLs as values
 *
 * @returns  resolved alias. If repository does not contain an alias the repository string will be returned. Should it contain an alias which can not be resolved using `registryAliases`, null will be returned
 */
function resolveAlias(repository, registryAliases) {
    if (!isAlias(repository)) {
        return repository;
    }
    const repoWithPrefixRemoved = repository.slice(repository[0] === '@' ? 1 : 6);
    const alias = registryAliases[repoWithPrefixRemoved];
    if (alias) {
        return alias;
    }
    return null;
}
exports.resolveAlias = resolveAlias;
function getRepositories(definitions) {
    const repositoryList = definitions
        .flatMap((value) => value.dependencies)
        .filter((dependency) => dependency.repository) // only keep non-local references --> if no repository is defined the chart will be searched in charts/<name>
        .filter((dependency) => !isAlias(dependency.repository)) // do not add registryAliases
        .filter((dependency) => !dependency.repository.startsWith('file:')) // skip repositories which are locally referenced
        .map((dependency) => {
        // remove additional keys to prevent interference at deduplication
        return {
            name: dependency.name,
            repository: dependency.repository,
        };
    });
    const dedup = new Set();
    return repositoryList.filter((el) => {
        const duplicate = dedup.has(el.repository);
        dedup.add(el.repository);
        return !duplicate;
    });
}
exports.getRepositories = getRepositories;
function isAlias(repository) {
    if (!repository) {
        return false;
    }
    return repository.startsWith('@') || repository.startsWith('alias:');
}
exports.isAlias = isAlias;
function isOCIRegistry(repository) {
    if (is_1.default.nullOrUndefined(repository)) {
        return false;
    }
    const repo = is_1.default.string(repository) ? repository : repository.repository;
    return repo.startsWith('oci://');
}
exports.isOCIRegistry = isOCIRegistry;
function aliasRecordToRepositories(registryAliases) {
    return Object.entries(registryAliases).map(([alias, url]) => {
        return {
            name: alias,
            repository: url,
        };
    });
}
exports.aliasRecordToRepositories = aliasRecordToRepositories;
function isFileInDir(dir, file) {
    return upath_1.default.dirname(file) === dir;
}
exports.isFileInDir = isFileInDir;
//# sourceMappingURL=utils.js.map