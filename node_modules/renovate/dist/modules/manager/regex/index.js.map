{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/manager/regex/index.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAQlC,6CAA6E;AAE7E,mCAA2C;AAE9B,QAAA,aAAa,GAAG;IAC3B,UAAU,EAAE,KAAK;CAClB,CAAC;AACW,QAAA,oBAAoB,GAAG,CAAC,GAAG,CAAC,CAAC;AAE1C,SAAgB,kBAAkB,CAChC,OAAe,EACf,WAAmB,EACnB,MAAqB;IAErB,IAAI,IAAyB,CAAC;IAC9B,QAAQ,MAAM,CAAC,oBAAoB,EAAE;QACnC,QAAQ;QACR,KAAK,KAAK;YACR,IAAI,GAAG,IAAA,sBAAS,EAAC,OAAO,EAAE,WAAW,EAAE,MAA4B,CAAC,CAAC;YACrE,MAAM;QACR,KAAK,aAAa;YAChB,IAAI,GAAG,IAAA,8BAAiB,EACtB,OAAO,EACP,WAAW,EACX,MAA4B,CAC7B,CAAC;YACF,MAAM;QACR,KAAK,WAAW;YACd,IAAI,GAAG,IAAA,4BAAe,EACpB,OAAO,EACP,WAAW,EACX,MAA4B,CAC7B,CAAC;YACF,MAAM;KACT;IAED,yBAAyB;IACzB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,YAAE,CAAC,MAAM,CAAC,CAAC;IAC9B,IAAI,IAAI,CAAC,MAAM,EAAE;QACf,MAAM,GAAG,GAA+C;YACtD,IAAI;YACJ,YAAY,EAAE,MAAM,CAAC,YAAY;SAClC,CAAC;QACF,IAAI,MAAM,CAAC,oBAAoB,EAAE;YAC/B,GAAG,CAAC,oBAAoB,GAAG,MAAM,CAAC,oBAAoB,CAAC;SACxD;QACD,sCAAsC;QACtC,KAAK,MAAM,KAAK,IAAI,wBAAgB,CAAC,GAAG,CACtC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,UAAyC,CACrD,EAAE;YACD,IAAI,MAAM,CAAC,KAAK,CAAC,EAAE;gBACjB,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;aAC5B;SACF;QACD,IAAI,MAAM,CAAC,yBAAyB,EAAE;YACpC,GAAG,CAAC,yBAAyB,GAAG,MAAM,CAAC,yBAAyB,CAAC;SAClE;QACD,OAAO,GAAG,CAAC;KACZ;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AApDD,gDAoDC","sourcesContent":["import is from '@sindresorhus/is';\nimport type { RegexManagerTemplates } from '../../../config/types';\nimport type {\n  ExtractConfig,\n  PackageDependency,\n  PackageFileContent,\n  Result,\n} from '../types';\nimport { handleAny, handleCombination, handleRecursive } from './strategies';\nimport type { RegexManagerConfig } from './types';\nimport { validMatchFields } from './utils';\n\nexport const defaultConfig = {\n  pinDigests: false,\n};\nexport const supportedDatasources = ['*'];\n\nexport function extractPackageFile(\n  content: string,\n  packageFile: string,\n  config: ExtractConfig\n): Result<PackageFileContent | null> {\n  let deps: PackageDependency[];\n  switch (config.matchStringsStrategy) {\n    default:\n    case 'any':\n      deps = handleAny(content, packageFile, config as RegexManagerConfig);\n      break;\n    case 'combination':\n      deps = handleCombination(\n        content,\n        packageFile,\n        config as RegexManagerConfig\n      );\n      break;\n    case 'recursive':\n      deps = handleRecursive(\n        content,\n        packageFile,\n        config as RegexManagerConfig\n      );\n      break;\n  }\n\n  // filter all null values\n  deps = deps.filter(is.truthy);\n  if (deps.length) {\n    const res: PackageFileContent & RegexManagerTemplates = {\n      deps,\n      matchStrings: config.matchStrings,\n    };\n    if (config.matchStringsStrategy) {\n      res.matchStringsStrategy = config.matchStringsStrategy;\n    }\n    // copy over templates for autoreplace\n    for (const field of validMatchFields.map(\n      (f) => `${f}Template` as keyof RegexManagerTemplates\n    )) {\n      if (config[field]) {\n        res[field] = config[field];\n      }\n    }\n    if (config.autoReplaceStringTemplate) {\n      res.autoReplaceStringTemplate = config.autoReplaceStringTemplate;\n    }\n    return res;\n  }\n\n  return null;\n}\n"]}