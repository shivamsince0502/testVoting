{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../lib/modules/datasource/custom/index.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAClC,8DAA8B;AAC9B,4CAAyC;AACzC,8CAA2C;AAE3C,qCAAkD;AAClD,mCAAwD;AAExD,MAAa,gBAAiB,SAAQ,uBAAU;IAC9C,MAAM,CAAU,EAAE,GAAG,QAAQ,CAAC;IAErB,qBAAqB,GAAG,IAAI,CAAC;IAEtC;QACE,KAAK,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,WAAW,CACf,iBAAoC;QAEpC,MAAM,oBAAoB,GAAG,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAChE,SAAS,EACT,EAAE,CACH,CAAC;QAEF,IAAI,CAAC,YAAE,CAAC,cAAc,CAAC,oBAAoB,CAAC,EAAE;YAC5C,eAAM,CAAC,KAAK,CACV,oDAAoD,iBAAiB,CAAC,WAAW,EAAE,CACpF,CAAC;YACF,OAAO,IAAI,CAAC;SACb;QAED,MAAM,MAAM,GAAG,IAAA,qCAA6B,EAC1C,oBAAoB,EACpB,iBAAiB,CAClB,CAAC;QACF,IAAI,YAAE,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE;YAC9B,OAAO,IAAI,CAAC;SACb;QAED,MAAM,EAAE,0BAA0B,EAAE,kBAAkB,EAAE,GAAG,MAAM,CAAC;QAClE,+CAA+C;QAC/C,IAAI,QAAiB,CAAC;QACtB,IAAI;YACF,QAAQ,GAAG,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,0BAA0B,CAAC,CAAC,CAAC,IAAI,CAAC;SACvE;QAAC,OAAO,CAAC,EAAE;YACV,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;YACzB,OAAO,IAAI,CAAC;SACb;QAED,IAAI,IAAI,GAAG,QAAQ,CAAC;QAEpB,KAAK,MAAM,iBAAiB,IAAI,kBAAkB,EAAE;YAClD,MAAM,UAAU,GAAG,IAAA,iBAAO,EAAC,iBAAiB,CAAC,CAAC;YAC9C,IAAI,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACxC;QAED,IAAI;YACF,MAAM,MAAM,GAAG,+BAAsB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAClD,OAAO,eAAe,CAAC,MAAM,CAAC,CAAC;SAChC;QAAC,OAAO,GAAG,EAAE;YACZ,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,gCAAgC,CAAC,CAAC;YACxD,eAAM,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,EAAE,qCAAqC,CAAC,CAAC;YAC9D,OAAO,IAAI,CAAC;SACb;IACH,CAAC;;AAzDH,4CA0DC","sourcesContent":["import is from '@sindresorhus/is';\nimport jsonata from 'jsonata';\nimport { logger } from '../../../logger';\nimport { Datasource } from '../datasource';\nimport type { GetReleasesConfig, ReleaseResult } from '../types';\nimport { ReleaseResultZodSchema } from './schema';\nimport { massageCustomDatasourceConfig } from './utils';\n\nexport class CustomDatasource extends Datasource {\n  static readonly id = 'custom';\n\n  override customRegistrySupport = true;\n\n  constructor() {\n    super(CustomDatasource.id);\n  }\n\n  async getReleases(\n    getReleasesConfig: GetReleasesConfig\n  ): Promise<ReleaseResult | null> {\n    const customDatasourceName = getReleasesConfig.datasource?.replace(\n      'custom.',\n      ''\n    );\n\n    if (!is.nonEmptyString(customDatasourceName)) {\n      logger.debug(\n        `No datasource has been supplied while looking up ${getReleasesConfig.packageName}`\n      );\n      return null;\n    }\n\n    const config = massageCustomDatasourceConfig(\n      customDatasourceName,\n      getReleasesConfig\n    );\n    if (is.nullOrUndefined(config)) {\n      return null;\n    }\n\n    const { defaultRegistryUrlTemplate, transformTemplates } = config;\n    // TODO add here other format options than JSON\n    let response: unknown;\n    try {\n      response = (await this.http.getJson(defaultRegistryUrlTemplate)).body;\n    } catch (e) {\n      this.handleHttpErrors(e);\n      return null;\n    }\n\n    let data = response;\n\n    for (const transformTemplate of transformTemplates) {\n      const expression = jsonata(transformTemplate);\n      data = await expression.evaluate(data);\n    }\n\n    try {\n      const parsed = ReleaseResultZodSchema.parse(data);\n      return structuredClone(parsed);\n    } catch (err) {\n      logger.debug({ err }, `Response has failed validation`);\n      logger.trace({ data }, 'Response that has failed validation');\n      return null;\n    }\n  }\n}\n"]}