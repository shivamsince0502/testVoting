"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldReuseExistingBranch = void 0;
const logger_1 = require("../../../../logger");
const platform_1 = require("../../../../modules/platform");
const scm_1 = require("../../../../modules/platform/scm");
async function shouldReuseExistingBranch(config) {
    const { baseBranch, branchName } = config;
    const result = { reuseExistingBranch: false };
    // Check if branch exists
    if (!(await scm_1.scm.branchExists(branchName))) {
        logger_1.logger.debug(`Branch needs creating`);
        return result;
    }
    logger_1.logger.debug(`Branch already exists`);
    if (config.rebaseWhen === 'behind-base-branch' ||
        (config.rebaseWhen === 'auto' &&
            (config.automerge || (await platform_1.platform.getRepoForceRebase())))) {
        if (await scm_1.scm.isBranchBehindBase(branchName, baseBranch)) {
            logger_1.logger.debug(`Branch is behind base branch and needs rebasing`);
            // We can rebase the branch only if no PR or PR can be rebased
            if (await scm_1.scm.isBranchModified(branchName)) {
                logger_1.logger.debug('Cannot rebase branch as it has been modified');
                result.reuseExistingBranch = true;
                result.isModified = true;
                return result;
            }
            logger_1.logger.debug('Branch is unmodified, so can be rebased');
            return result;
        }
        logger_1.logger.debug('Branch is up-to-date');
    }
    else {
        logger_1.logger.debug(`Skipping behind base branch check due to rebaseWhen=${config.rebaseWhen}`);
    }
    // Now check if PR is unmergeable. If so then we also rebase
    result.isConflicted = await scm_1.scm.isBranchConflicted(baseBranch, branchName);
    if (result.isConflicted) {
        logger_1.logger.debug('Branch is conflicted');
        if ((await scm_1.scm.isBranchModified(branchName)) === false) {
            logger_1.logger.debug(`Branch is not mergeable and needs rebasing`);
            if (config.rebaseWhen === 'never') {
                logger_1.logger.debug('Rebasing disabled by config');
                result.reuseExistingBranch = true;
                result.isModified = false;
            }
            // Setting reuseExistingBranch back to undefined means that we'll use the default branch
            return result;
        }
        // Don't do anything different, but warn
        // TODO: Add warning to PR (#9720)
        logger_1.logger.debug(`Branch is not mergeable but can't be rebased`);
    }
    logger_1.logger.debug(`Branch does not need rebasing`);
    // Branches can get in an inconsistent state if "update-lockfile" is used at the same time as other strategies
    // On the first execution, everything is executed, but if on a second execution the package.json modification is
    // skipped but the lockfile update is executed, the lockfile will have a different result than if it was executed
    // along with the changes to the package.json. Thus ending up with an incomplete branch update
    // This is why we are skipping branch reuse in this case (#10050)
    const groupedByPackageFile = {};
    for (const upgrade of config.upgrades) {
        const packageFile = upgrade.packageFile;
        groupedByPackageFile[packageFile] ??= new Set();
        groupedByPackageFile[packageFile].add(upgrade.rangeStrategy);
        if (groupedByPackageFile[packageFile].size > 1 &&
            groupedByPackageFile[packageFile].has('update-lockfile')) {
            logger_1.logger.debug(`Detected multiple rangeStrategies along with update-lockfile`);
            result.reuseExistingBranch = false;
            result.isModified = false;
            return result;
        }
    }
    result.reuseExistingBranch = true;
    result.isModified = false;
    return result;
}
exports.shouldReuseExistingBranch = shouldReuseExistingBranch;
//# sourceMappingURL=reuse.js.map