"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Url = exports.UtcDate = exports.Json5 = exports.Json = exports.LooseRecord = exports.LooseArray = void 0;
const tslib_1 = require("tslib");
const json5_1 = tslib_1.__importDefault(require("json5"));
const luxon_1 = require("luxon");
const zod_1 = require("zod");
/**
 * Works like `z.array()`, but drops wrong elements instead of invalidating the whole array.
 *
 * **Important**: non-array inputs are still invalid.
 * Use `LooseArray(...).catch([])` to handle it.
 *
 * @param Elem Schema for array elements
 * @param onError Callback for errors
 * @returns Schema for array
 */
function LooseArray(Elem, { onError } = {}) {
    if (!onError) {
        // Avoid error-related computations inside the loop
        return zod_1.z.array(zod_1.z.any()).transform((input) => {
            const output = [];
            for (const x of input) {
                const parsed = Elem.safeParse(x);
                if (parsed.success) {
                    output.push(parsed.data);
                }
            }
            return output;
        });
    }
    return zod_1.z.array(zod_1.z.any()).transform((input) => {
        const output = [];
        const issues = [];
        for (let idx = 0; idx < input.length; idx += 1) {
            const x = input[idx];
            const parsed = Elem.safeParse(x);
            if (parsed.success) {
                output.push(parsed.data);
                continue;
            }
            for (const issue of parsed.error.issues) {
                issue.path.unshift(idx);
                issues.push(issue);
            }
        }
        if (issues.length) {
            const error = new zod_1.z.ZodError(issues);
            onError({ error, input });
        }
        return output;
    });
}
exports.LooseArray = LooseArray;
function LooseRecord(arg1, arg2, arg3) {
    let Key = zod_1.z.any();
    let Value;
    let opts = {};
    if (arg2 && arg3) {
        Key = arg1;
        Value = arg2;
        opts = arg3;
    }
    else if (arg2) {
        if (arg2 instanceof zod_1.z.ZodType) {
            Key = arg1;
            Value = arg2;
        }
        else {
            Value = arg1;
            opts = arg2;
        }
    }
    else {
        Value = arg1;
    }
    const { onError } = opts;
    if (!onError) {
        // Avoid error-related computations inside the loop
        return zod_1.z.record(zod_1.z.any()).transform((input) => {
            const output = {};
            for (const [inputKey, inputVal] of Object.entries(input)) {
                const parsedKey = Key.safeParse(inputKey);
                const parsedValue = Value.safeParse(inputVal);
                if (parsedKey.success && parsedValue.success) {
                    output[parsedKey.data] = parsedValue.data;
                }
            }
            return output;
        });
    }
    return zod_1.z.record(zod_1.z.any()).transform((input) => {
        const output = {};
        const issues = [];
        for (const [inputKey, inputVal] of Object.entries(input)) {
            const parsedKey = Key.safeParse(inputKey);
            if (!parsedKey.success) {
                for (const issue of parsedKey.error.issues) {
                    issue.path.unshift(inputKey);
                    issues.push(issue);
                }
                continue;
            }
            const parsedValue = Value.safeParse(inputVal);
            if (!parsedValue.success) {
                for (const issue of parsedValue.error.issues) {
                    issue.path.unshift(inputKey);
                    issues.push(issue);
                }
                continue;
            }
            output[parsedKey.data] = parsedValue.data;
            continue;
        }
        if (issues.length) {
            const error = new zod_1.z.ZodError(issues);
            onError({ error, input });
        }
        return output;
    });
}
exports.LooseRecord = LooseRecord;
exports.Json = zod_1.z.string().transform((str, ctx) => {
    try {
        return JSON.parse(str);
    }
    catch (e) {
        ctx.addIssue({ code: 'custom', message: 'Invalid JSON' });
        return zod_1.z.NEVER;
    }
});
exports.Json5 = zod_1.z.string().transform((str, ctx) => {
    try {
        return json5_1.default.parse(str);
    }
    catch (e) {
        ctx.addIssue({ code: 'custom', message: 'Invalid JSON5' });
        return zod_1.z.NEVER;
    }
});
exports.UtcDate = zod_1.z
    .string({ description: 'ISO 8601 string' })
    .transform((str, ctx) => {
    const date = luxon_1.DateTime.fromISO(str, { zone: 'utc' });
    if (!date.isValid) {
        ctx.addIssue({ code: 'custom', message: 'Invalid date' });
        return zod_1.z.NEVER;
    }
    return date;
});
exports.Url = zod_1.z.string().transform((str, ctx) => {
    try {
        return new URL(str);
    }
    catch (e) {
        ctx.addIssue({ code: 'custom', message: 'Invalid URL' });
        return zod_1.z.NEVER;
    }
});
//# sourceMappingURL=schema-utils.js.map