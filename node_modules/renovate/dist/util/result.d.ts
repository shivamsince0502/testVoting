interface Ok<T> {
    readonly success: true;
    readonly value: T;
}
interface Err<E> {
    readonly success: false;
    readonly error: E;
}
type Res<T, E> = Ok<T> | Err<E>;
export declare class Result<T, E = Error> {
    readonly res: Res<T, E>;
    static ok<T>(value: T): Result<T, never>;
    static err(): Result<never, true>;
    static err<E>(e: E): Result<never, E>;
    private static wrapCallback;
    private static wrapPromise;
    static wrap<T>(callback: () => T): Result<T>;
    static wrap<T>(promise: Promise<T>): Promise<Result<T>>;
    private constructor();
    transform<U>(fn: (value: T) => U): Result<U, E>;
    catch<U>(fallback: U): T | U;
    get value(): T | undefined;
    get error(): E | undefined;
}
export {};
