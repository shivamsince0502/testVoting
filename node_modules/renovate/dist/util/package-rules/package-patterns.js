"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackagePatternsMatcher = void 0;
const tslib_1 = require("tslib");
const is_1 = tslib_1.__importDefault(require("@sindresorhus/is"));
const logger_1 = require("../../logger");
const regex_1 = require("../regex");
const base_1 = require("./base");
const utils_1 = require("./utils");
function matchPatternsAgainstName(matchPackagePatterns, name) {
    let isMatch = false;
    for (const packagePattern of matchPackagePatterns) {
        if (isPackagePatternMatch(packagePattern, name)) {
            isMatch = true;
        }
    }
    return isMatch;
}
class PackagePatternsMatcher extends base_1.Matcher {
    matches({ depName, packageName }, packageRule) {
        const { matchPackagePatterns } = packageRule;
        if (is_1.default.undefined(matchPackagePatterns)) {
            return null;
        }
        if (is_1.default.undefined(depName)) {
            return false;
        }
        if (is_1.default.string(packageName) &&
            matchPatternsAgainstName(matchPackagePatterns, packageName)) {
            return true;
        }
        if (matchPatternsAgainstName(matchPackagePatterns, depName)) {
            logger_1.logger.once.info({ packageRule, packageName, depName }, 'Use matchDepPatterns instead of matchPackagePatterns');
            return true;
        }
        return false;
    }
    excludes({ depName }, { excludePackagePatterns }) {
        // ignore lockFileMaintenance for backwards compatibility
        if (is_1.default.undefined(excludePackagePatterns)) {
            return null;
        }
        if (is_1.default.undefined(depName)) {
            return false;
        }
        let isMatch = false;
        for (const pattern of excludePackagePatterns) {
            const packageRegex = (0, regex_1.regEx)((0, utils_1.massagePattern)(pattern));
            if (packageRegex.test(depName)) {
                logger_1.logger.trace(`${depName} matches against ${String(packageRegex)}`);
                isMatch = true;
            }
        }
        return isMatch;
    }
}
exports.PackagePatternsMatcher = PackagePatternsMatcher;
function isPackagePatternMatch(pckPattern, pck) {
    const re = (0, regex_1.regEx)((0, utils_1.massagePattern)(pckPattern));
    if (re.test(pck)) {
        logger_1.logger.trace(`${pck} matches against ${String(re)}`);
        return true;
    }
    return false;
}
//# sourceMappingURL=package-patterns.js.map