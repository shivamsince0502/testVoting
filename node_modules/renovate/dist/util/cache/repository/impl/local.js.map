{"version":3,"file":"local.js","sourceRoot":"","sources":["../../../../../lib/util/cache/repository/impl/local.ts"],"names":[],"mappings":";;;;AAAA,0DAA0B;AAC1B,sDAAyD;AACzD,+CAA4C;AAC5C,oCAA8E;AAE9E,iCAAuC;AAEvC,MAAa,cAAe,SAAQ,oBAAa;IAC/C,YAAY,UAAkB,EAAE,WAAmB;QACjD,KAAK,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;IACjC,CAAC;IAES,KAAK,CAAC,IAAI;QAClB,MAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC9C,IAAI;YACF,kCAAkC;YAClC,IAAI,CAAC,CAAC,MAAM,IAAA,oBAAe,EAAC,aAAa,CAAC,CAAC,EAAE;gBAC3C,OAAO,IAAI,CAAC;aACb;YACD,OAAO,MAAM,IAAA,kBAAa,EAAC,aAAa,EAAE,MAAM,CAAC,CAAC;SACnD;QAAC,OAAO,GAAG,EAAE;YACZ,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,aAAa,EAAE,EAAE,kCAAkC,CAAC,CAAC;SAC1E;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAES,KAAK,CAAC,KAAK,CAAC,IAAqB;QACzC,MAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC9C,MAAM,IAAA,oBAAe,EAAC,aAAa,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7D,CAAC;IAEO,gBAAgB;QACtB,MAAM,QAAQ,GAAG,qBAAY,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC9C,MAAM,aAAa,GAAG,uBAAuB,CAAC;QAC9C,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,QAAQ,GAAG,GAAG,IAAI,CAAC,UAAU,OAAO,CAAC;QAC3C,OAAO,eAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,aAAa,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACjE,CAAC;CACF;AA/BD,wCA+BC","sourcesContent":["import upath from 'upath';\nimport { GlobalConfig } from '../../../../config/global';\nimport { logger } from '../../../../logger';\nimport { cachePathExists, outputCacheFile, readCacheFile } from '../../../fs';\nimport type { RepoCacheRecord } from '../schema';\nimport { RepoCacheBase } from './base';\n\nexport class RepoCacheLocal extends RepoCacheBase {\n  constructor(repository: string, fingerprint: string) {\n    super(repository, fingerprint);\n  }\n\n  protected async read(): Promise<string | null> {\n    const cacheFileName = this.getCacheFileName();\n    try {\n      // suppress debug logs with errros\n      if (!(await cachePathExists(cacheFileName))) {\n        return null;\n      }\n      return await readCacheFile(cacheFileName, 'utf8');\n    } catch (err) {\n      logger.debug({ err, cacheFileName }, 'Repository local cache not found');\n    }\n    return null;\n  }\n\n  protected async write(data: RepoCacheRecord): Promise<void> {\n    const cacheFileName = this.getCacheFileName();\n    await outputCacheFile(cacheFileName, JSON.stringify(data));\n  }\n\n  private getCacheFileName(): string {\n    const cacheDir = GlobalConfig.get('cacheDir');\n    const repoCachePath = '/renovate/repository/';\n    const platform = this.platform;\n    const fileName = `${this.repository}.json`;\n    return upath.join(cacheDir, repoCachePath, platform, fileName);\n  }\n}\n"]}