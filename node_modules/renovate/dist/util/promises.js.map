{"version":3,"file":"promises.js","sourceRoot":"","sources":["../../lib/util/promises.ts"],"names":[],"mappings":";;;;AAAA,8EAA6C;AAC7C,0DAAyB;AACzB,0DAAyB;AACzB,sCAAmC;AACnC,6EAAwE;AAIxE,SAAS,mBAAmB,CAAC,GAAQ;IACnC,OAAO,GAAG,YAAY,uCAAiB,CAAC;AAC1C,CAAC;AAED,SAAS,WAAW,CAAC,GAAQ;IAC3B,IAAI,CAAC,CAAC,GAAG,YAAY,yBAAc,CAAC,EAAE;QACpC,MAAM,GAAG,CAAC;KACX;IAED,eAAM,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE,EAAE,2BAA2B,CAAC,CAAC;IAEnD,MAAM,MAAM,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;IAExB,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;IACnD,IAAI,SAAS,EAAE;QACb,MAAM,SAAS,CAAC;KACjB;IAED,IACE,MAAM,CAAC,MAAM,KAAK,CAAC;QACnB,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,EACxD;QACA,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC;QACvB,MAAM,KAAK,CAAC;KACb;IAED,MAAM,GAAG,CAAC;AACZ,CAAC;AAEM,KAAK,UAAU,GAAG,CACvB,KAA0B,EAC1B,OAAsB;IAEtB,IAAI;QACF,MAAM,GAAG,GAAG,MAAM,IAAA,eAAI,EAAC,KAAK,EAAE;YAC5B,WAAW,EAAE,CAAC;YACd,WAAW,EAAE,KAAK;YAClB,GAAG,OAAO;SACX,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;KACZ;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;KACzB;AACH,CAAC;AAdD,kBAcC;AAEM,KAAK,UAAU,GAAG,CACvB,KAAwB,EACxB,MAAwC,EACxC,OAAsB;IAEtB,IAAI;QACF,MAAM,GAAG,GAAG,MAAM,IAAA,eAAI,EAAC,KAAK,EAAE,MAAM,EAAE;YACpC,WAAW,EAAE,CAAC;YACd,WAAW,EAAE,KAAK;YAClB,GAAG,OAAO;SACX,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;KACZ;IAAC,OAAO,GAAG,EAAE;QACZ,OAAO,WAAW,CAAC,GAAG,CAAC,CAAC;KACzB;AACH,CAAC;AAfD,kBAeC","sourcesContent":["import AggregateError from 'aggregate-error';\nimport pAll from 'p-all';\nimport pMap from 'p-map';\nimport { logger } from '../logger';\nimport { ExternalHostError } from '../types/errors/external-host-error';\n\ntype PromiseFactory<T> = () => Promise<T>;\n\nfunction isExternalHostError(err: any): err is ExternalHostError {\n  return err instanceof ExternalHostError;\n}\n\nfunction handleError(err: any): never {\n  if (!(err instanceof AggregateError)) {\n    throw err;\n  }\n\n  logger.debug({ err }, 'Aggregate error is thrown');\n\n  const errors = [...err];\n\n  const hostError = errors.find(isExternalHostError);\n  if (hostError) {\n    throw hostError;\n  }\n\n  if (\n    errors.length === 1 ||\n    new Set(errors.map(({ message }) => message)).size === 1\n  ) {\n    const [error] = errors;\n    throw error;\n  }\n\n  throw err;\n}\n\nexport async function all<T>(\n  tasks: PromiseFactory<T>[],\n  options?: pAll.Options\n): Promise<T[]> {\n  try {\n    const res = await pAll(tasks, {\n      concurrency: 5,\n      stopOnError: false,\n      ...options,\n    });\n    return res;\n  } catch (err) {\n    return handleError(err);\n  }\n}\n\nexport async function map<Element, NewElement>(\n  input: Iterable<Element>,\n  mapper: pMap.Mapper<Element, NewElement>,\n  options?: pMap.Options\n): Promise<NewElement[]> {\n  try {\n    const res = await pMap(input, mapper, {\n      concurrency: 5,\n      stopOnError: false,\n      ...options,\n    });\n    return res;\n  } catch (err) {\n    return handleError(err);\n  }\n}\n"]}