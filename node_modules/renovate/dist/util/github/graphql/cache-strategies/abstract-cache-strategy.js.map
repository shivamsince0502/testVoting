{"version":3,"file":"abstract-cache-strategy.js","sourceRoot":"","sources":["../../../../../lib/util/github/graphql/cache-strategies/abstract-cache-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { dequal } from 'dequal';\nimport { DateTime } from 'luxon';\nimport type {\n  GithubDatasourceItem,\n  GithubGraphqlCacheRecord,\n  GithubGraphqlCacheStrategy,\n} from '../types';\nimport { isDateExpired } from '../util';\n\n/**\n * Cache strategy handles the caching Github GraphQL items\n * and reconciling them with newly obtained ones from paginated queries.\n */\nexport abstract class AbstractGithubGraphqlCacheStrategy<\n  GithubItem extends GithubDatasourceItem\n> implements GithubGraphqlCacheStrategy<GithubItem>\n{\n  /**\n   * Time period after which a cache record is considered expired.\n   */\n  protected static readonly cacheTTLDays = 30;\n\n  /**\n   * The time which is used during single cache access cycle.\n   */\n  protected readonly now = DateTime.now().toUTC();\n\n  /**\n   * Set of all versions which were reconciled\n   * during the current cache access cycle.\n   */\n  private readonly reconciledVersions = new Set<string>();\n\n  /**\n   * These fields will be persisted.\n   */\n  private items: Record<string, GithubItem> | undefined;\n  protected createdAt = this.now;\n\n  /**\n   * This flag helps to indicate whether the cache record\n   * should be persisted after the current cache access cycle.\n   */\n  protected hasUpdatedItems = false;\n\n  /**\n   * Loading and persisting data is delegated to the concrete strategy.\n   */\n  abstract load(): Promise<GithubGraphqlCacheRecord<GithubItem> | undefined>;\n  abstract persist(\n    cacheRecord: GithubGraphqlCacheRecord<GithubItem>\n  ): Promise<void>;\n\n  constructor(\n    protected readonly cacheNs: string,\n    protected readonly cacheKey: string\n  ) {}\n\n  /**\n   * Load data previously persisted by this strategy\n   * for given `cacheNs` and `cacheKey`.\n   */\n  private async getItems(): Promise<Record<string, GithubItem>> {\n    if (this.items) {\n      return this.items;\n    }\n\n    let result: GithubGraphqlCacheRecord<GithubItem> = {\n      items: {},\n      createdAt: this.createdAt.toISO()!,\n    };\n\n    const storedData = await this.load();\n    if (storedData) {\n      const cacheTTLDuration = {\n        hours: AbstractGithubGraphqlCacheStrategy.cacheTTLDays * 24,\n      };\n      if (!isDateExpired(this.now, storedData.createdAt, cacheTTLDuration)) {\n        result = storedData;\n      }\n    }\n\n    this.createdAt = DateTime.fromISO(result.createdAt).toUTC();\n    this.items = result.items;\n    return this.items;\n  }\n\n  /**\n   * If package release exists longer than this cache can exist,\n   * we assume it won't updated/removed on the Github side.\n   */\n  private isStabilized(item: GithubItem): boolean {\n    const unstableDuration = {\n      hours: AbstractGithubGraphqlCacheStrategy.cacheTTLDays * 24,\n    };\n    return isDateExpired(this.now, item.releaseTimestamp, unstableDuration);\n  }\n\n  /**\n   * Process items received from GraphQL page\n   * ordered by `releaseTimestamp` in descending order\n   * (fresh versions go first).\n   */\n  async reconcile(items: GithubItem[]): Promise<boolean> {\n    const cachedItems = await this.getItems();\n\n    let isPaginationDone = false;\n    for (const item of items) {\n      const { version } = item;\n\n      // If we reached previously stored item that is stabilized,\n      // we assume the further pagination will not yield any new items.\n      const oldItem = cachedItems[version];\n      if (oldItem) {\n        if (this.isStabilized(oldItem)) {\n          isPaginationDone = true;\n        }\n\n        if (!dequal(oldItem, item)) {\n          this.hasUpdatedItems = true;\n        }\n      }\n\n      cachedItems[version] = item;\n      this.reconciledVersions.add(version);\n    }\n\n    this.items = cachedItems;\n    return isPaginationDone;\n  }\n\n  /**\n   * Handle removed items for packages that are not stabilized\n   * and return the list of all items.\n   */\n  async finalize(): Promise<GithubItem[]> {\n    const cachedItems = await this.getItems();\n    const resultItems: Record<string, GithubItem> = {};\n\n    for (const [version, item] of Object.entries(cachedItems)) {\n      if (this.isStabilized(item) || this.reconciledVersions.has(version)) {\n        resultItems[version] = item;\n      }\n    }\n\n    await this.store(resultItems);\n    return Object.values(resultItems);\n  }\n\n  private async store(cachedItems: Record<string, GithubItem>): Promise<void> {\n    const cacheRecord: GithubGraphqlCacheRecord<GithubItem> = {\n      items: cachedItems,\n      createdAt: this.createdAt.toISO()!,\n    };\n    await this.persist(cacheRecord);\n  }\n}\n"]}