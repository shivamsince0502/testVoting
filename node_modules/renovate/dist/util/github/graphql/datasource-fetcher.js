"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GithubGraphqlDatasourceFetcher = void 0;
const tslib_1 = require("tslib");
const aggregate_error_1 = tslib_1.__importDefault(require("aggregate-error"));
const logger_1 = require("../../../logger");
const external_host_error_1 = require("../../../types/errors/external-host-error");
const memCache = tslib_1.__importStar(require("../../cache/memory"));
const url_1 = require("../url");
const memory_cache_strategy_1 = require("./cache-strategies/memory-cache-strategy");
const package_cache_strategy_1 = require("./cache-strategies/package-cache-strategy");
/**
 * We know empirically that certain type of GraphQL errors
 * can be fixed by shrinking page size.
 *
 * @see https://github.com/renovatebot/renovate/issues/16343
 */
function isUnknownGraphqlError(err) {
    const { message } = err;
    return message.startsWith('Something went wrong while executing your query.');
}
function canBeSolvedByShrinking(err) {
    const errors = err instanceof aggregate_error_1.default ? [...err] : [err];
    return errors.some((e) => err instanceof external_host_error_1.ExternalHostError || isUnknownGraphqlError(e));
}
class GithubGraphqlDatasourceFetcher {
    http;
    datasourceAdapter;
    static async query(config, http, adapter) {
        const instance = new GithubGraphqlDatasourceFetcher(config, http, adapter);
        const items = await instance.getItems();
        return items;
    }
    baseUrl;
    repoOwner;
    repoName;
    itemsPerQuery = 100;
    queryCount = 0;
    cursor = null;
    isCacheable = null;
    constructor(packageConfig, http, datasourceAdapter) {
        this.http = http;
        this.datasourceAdapter = datasourceAdapter;
        const { packageName, registryUrl } = packageConfig;
        [this.repoOwner, this.repoName] = packageName.split('/');
        this.baseUrl = (0, url_1.getApiBaseUrl)(registryUrl).replace(/\/v3\/$/, '/'); // Replace for GHE
    }
    getCacheNs() {
        return this.datasourceAdapter.key;
    }
    getCacheKey() {
        return [this.baseUrl, this.repoOwner, this.repoName].join(':');
    }
    getRawQueryOptions() {
        const baseUrl = this.baseUrl;
        const repository = `${this.repoOwner}/${this.repoName}`;
        const query = this.datasourceAdapter.query;
        const variables = {
            owner: this.repoOwner,
            name: this.repoName,
            count: this.itemsPerQuery,
            cursor: this.cursor,
        };
        return {
            baseUrl,
            repository,
            body: { query, variables },
        };
    }
    async doRawQuery() {
        const requestOptions = this.getRawQueryOptions();
        let httpRes;
        try {
            httpRes = await this.http.postJson('/graphql', requestOptions);
        }
        catch (err) {
            return [null, err];
        }
        const { body } = httpRes;
        const { data, errors } = body;
        if (errors?.length) {
            if (errors.length === 1) {
                const { message } = errors[0];
                const err = new Error(message);
                return [null, err];
            }
            else {
                const errorInstances = errors.map(({ message }) => new Error(message));
                const err = new aggregate_error_1.default(errorInstances);
                return [null, err];
            }
        }
        if (!data) {
            const msg = 'GitHub GraphQL datasource: failed to obtain data';
            const err = new Error(msg);
            return [null, err];
        }
        if (!data.repository) {
            const msg = 'GitHub GraphQL datasource: failed to obtain repository data';
            const err = new Error(msg);
            return [null, err];
        }
        if (!data.repository.payload) {
            const msg = 'GitHub GraphQL datasource: failed to obtain repository payload data';
            const err = new Error(msg);
            return [null, err];
        }
        this.queryCount += 1;
        if (this.isCacheable === null) {
            // For values other than explicit `false`,
            // we assume that items can not be cached.
            this.isCacheable = data.repository.isRepoPrivate === false;
        }
        const res = data.repository.payload;
        return [res, null];
    }
    shrinkPageSize() {
        if (this.itemsPerQuery === 100) {
            this.itemsPerQuery = 50;
            return true;
        }
        if (this.itemsPerQuery === 50) {
            this.itemsPerQuery = 25;
            return true;
        }
        return false;
    }
    hasReachedQueryLimit() {
        return this.queryCount >= 100;
    }
    async doShrinkableQuery() {
        let res = null;
        let err = null;
        while (!res) {
            [res, err] = await this.doRawQuery();
            if (err) {
                if (!canBeSolvedByShrinking(err)) {
                    throw err;
                }
                const shrinkResult = this.shrinkPageSize();
                if (!shrinkResult) {
                    throw err;
                }
                const { body, ...options } = this.getRawQueryOptions();
                logger_1.logger.debug({ options, newSize: this.itemsPerQuery }, 'Shrinking GitHub GraphQL page size after error');
            }
        }
        return res;
    }
    _cacheStrategy;
    cacheStrategy() {
        if (this._cacheStrategy) {
            return this._cacheStrategy;
        }
        const cacheNs = this.getCacheNs();
        const cacheKey = this.getCacheKey();
        this._cacheStrategy = this.isCacheable
            ? new package_cache_strategy_1.GithubGraphqlPackageCacheStrategy(cacheNs, cacheKey)
            : new memory_cache_strategy_1.GithubGraphqlMemoryCacheStrategy(cacheNs, cacheKey);
        return this._cacheStrategy;
    }
    async doPaginatedQuery() {
        let hasNextPage = true;
        let isPaginationDone = false;
        let nextCursor;
        while (hasNextPage && !isPaginationDone && !this.hasReachedQueryLimit()) {
            const queryResult = await this.doShrinkableQuery();
            const resultItems = [];
            for (const node of queryResult.nodes) {
                const item = this.datasourceAdapter.transform(node);
                if (!item) {
                    logger_1.logger.once.info({
                        packageName: `${this.repoOwner}/${this.repoName}`,
                        baseUrl: this.baseUrl,
                    }, `GitHub GraphQL datasource: skipping empty item`);
                    continue;
                }
                resultItems.push(item);
            }
            // It's important to call `getCacheStrategy()` after `doShrinkableQuery()`
            // because `doShrinkableQuery()` may change `this.isCacheable`.
            //
            // Otherwise, cache items for public packages will never be persisted
            // in long-term cache.
            isPaginationDone = await this.cacheStrategy().reconcile(resultItems);
            hasNextPage = !!queryResult?.pageInfo?.hasNextPage;
            nextCursor = queryResult?.pageInfo?.endCursor;
            if (hasNextPage && nextCursor) {
                this.cursor = nextCursor;
            }
        }
        return this.cacheStrategy().finalize();
    }
    /**
     * This method intentionally was made not async, though it returns `Promise`.
     * This method doesn't make pages to be fetched concurrently.
     * Instead, it ensures that same package release is not fetched twice.
     */
    doConcurrentQuery() {
        const cacheKey = `github-pending:${this.getCacheNs()}:${this.getCacheKey()}`;
        const resultPromise = memCache.get(cacheKey) ?? this.doPaginatedQuery();
        memCache.set(cacheKey, resultPromise);
        return resultPromise;
    }
    async getItems() {
        const res = await this.doConcurrentQuery();
        return res;
    }
}
exports.GithubGraphqlDatasourceFetcher = GithubGraphqlDatasourceFetcher;
//# sourceMappingURL=datasource-fetcher.js.map