"use strict";
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference lib="dom" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExpressionAst = exports.getReferencesInExpression = exports.convertFiles = exports.parse = void 0;
// Inspired by
// https://github.com/ts-terraform/ts-terraform
// https://github.com/aaronpowell/webpack-golang-wasm-async-loader
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const deepmerge_1 = require("./deepmerge");
const zlib_1 = require("zlib");
const references_1 = require("./references");
const util_1 = require("./util");
// eslint-disable-next-line @typescript-eslint/ban-types
const jsRoot = {};
function sleep() {
    return new Promise((resolve) => {
        setTimeout(resolve, 0);
    });
}
function goBridge(getBytes) {
    let ready = false;
    async function init() {
        // After: https://github.com/golang/go/commit/680caf15355057ca84857a2a291b6f5c44e73329
        // Go 1.19+ has a different entrypoint
        await Promise.resolve().then(() => __importStar(require(`../wasm/bridge_wasm_exec.js`)));
        const go = new global.Go();
        const bytes = await getBytes;
        const result = await WebAssembly.instantiate(bytes, go.importObject);
        global.__parse_terraform_config_wasm__ = jsRoot;
        void go.run(result.instance);
        ready = true;
    }
    init().catch((error) => {
        throw error;
    });
    const proxy = new Proxy({}, {
        get: (_, key) => {
            return async (...args) => {
                while (!ready) {
                    await sleep();
                }
                if (!(key in jsRoot)) {
                    throw new Error(`There is nothing defined with the name "${key.toString()}"`);
                }
                if (typeof jsRoot[key] !== "function") {
                    return jsRoot[key];
                }
                return new Promise((resolve, reject) => {
                    const cb = (err, ...msg) => 
                    // @ts-ignore
                    err ? reject(new Error(err)) : resolve(...msg);
                    const run = () => {
                        jsRoot[key].apply(undefined, [...args, cb]);
                    };
                    run();
                });
            };
        },
    });
    return proxy;
}
const loadWasm = async () => {
    return (0, zlib_1.gunzipSync)(await fs_extra_1.default.readFile(path_1.default.join(__dirname, "..", "main.wasm.gz")));
};
const wasm = goBridge(loadWasm());
async function parse(filename, contents) {
    const res = await wasm.parse(filename, contents);
    return JSON.parse(res);
}
exports.parse = parse;
async function convertFiles(workingDirectory) {
    let tfFileContents = "";
    const tfJSONFileContents = [];
    for (const file of fs_extra_1.default.readdirSync(workingDirectory)) {
        const filePath = path_1.default.resolve(workingDirectory, file);
        if (!fs_extra_1.default.lstatSync(filePath).isDirectory()) {
            if (file.match(/\.tf$/)) {
                tfFileContents += fs_extra_1.default.readFileSync(filePath, "utf-8");
                tfFileContents += "\n";
            }
            else if (file.match(/\.tf\.json$/)) {
                tfJSONFileContents.push(JSON.parse(fs_extra_1.default.readFileSync(filePath, "utf-8")));
            }
        }
    }
    if (tfFileContents === "" && tfJSONFileContents.length === 0) {
        console.error(`No '.tf' or '.tf.json' files found in ${workingDirectory}`);
        return {};
    }
    return (0, deepmerge_1.deepMerge)(await parse("hcl2json.tf", tfFileContents), ...tfJSONFileContents);
}
exports.convertFiles = convertFiles;
/**
 * Parse a Terraform expression and return the AST. This function expects a string input, and will wrap the expression in quotes if it is not already quoted.
 * @param filename The filename to use for the expression. This is used for error reporting.
 * @param expression The expression to parse.
 * @returns An array of References found in the expression.
 */
async function getReferencesInExpression(filename, expression) {
    // We have to do this twice because of the problem with HEREDOCS
    // Our current hcl2json implementation removes HEREDOCS and replaces them
    // with a multi-line string, which is causing all kinds of problems
    let offset = 0;
    let quoteWrappedExpression = expression;
    if (!expression.startsWith('"') && !expression.startsWith("'")) {
        quoteWrappedExpression = `"${expression}"`;
        offset = 1;
    }
    const { wrap: wrappedExpression, wrapOffset: startOffset } = (0, util_1.wrapTerraformExpression)(`${quoteWrappedExpression}`);
    offset += startOffset;
    const ast = await getExpressionAst(filename, wrappedExpression);
    if (!ast) {
        return [];
    }
    const refs = (0, references_1.findAllReferencesInAst)(expression, ast);
    if (wrappedExpression === expression) {
        return refs;
    }
    return refs.map((ref) => {
        return {
            ...ref,
            startPosition: ref.startPosition - offset,
            endPosition: ref.endPosition - offset,
        };
    });
}
exports.getReferencesInExpression = getReferencesInExpression;
/**
 * Parse a Terraform expression and return the AST. The expression does not need to be a Terraform string.
 * @param filename The filename to use for the expression. This is used for error reporting.
 * @param expression The expression to parse.
 * @returns The AST for the expression.
 *
 *   The returned AST has the following structure:
 *   - type: The type of the node. This is a string.
 *   - range: This contains the start and end of the node in the expression.
 *   - children: This contains the children of the node. This is an array of nodes.
 *   - meta: This contains metadata about the node. This is an object, and varies depending on the type of the node.
 */
async function getExpressionAst(filename, expression) {
    const res = await wasm.getExpressionAst(filename, expression);
    const ast = JSON.parse(res);
    if (!ast) {
        return null;
    }
    return ast;
}
exports.getExpressionAst = getExpressionAst;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJpZGdlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJpZGdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLHFFQUFxRTtBQUNyRSwyQkFBMkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRTNCLGNBQWM7QUFDZCwrQ0FBK0M7QUFDL0Msa0VBQWtFO0FBRWxFLHdEQUEwQjtBQUMxQixnREFBd0I7QUFDeEIsMkNBQXdDO0FBQ3hDLCtCQUFrQztBQUNsQyw2Q0FBaUU7QUFFakUsaUNBQWlEO0FBUWpELHdEQUF3RDtBQUN4RCxNQUFNLE1BQU0sR0FBNkIsRUFBRSxDQUFDO0FBRTVDLFNBQVMsS0FBSztJQUNaLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtRQUM3QixVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFDLFFBQXlCO0lBQ3pDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztJQUVsQixLQUFLLFVBQVUsSUFBSTtRQUNqQixzRkFBc0Y7UUFDdEYsc0NBQXNDO1FBQ3RDLHdEQUFhLDZCQUE2QixHQUFDLENBQUM7UUFDNUMsTUFBTSxFQUFFLEdBQUcsSUFBSyxNQUFjLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDcEMsTUFBTSxLQUFLLEdBQUcsTUFBTSxRQUFRLENBQUM7UUFDN0IsTUFBTSxNQUFNLEdBQUcsTUFBTSxXQUFXLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEUsTUFBYyxDQUFDLCtCQUErQixHQUFHLE1BQU0sQ0FBQztRQUN6RCxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdCLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDZixDQUFDO0lB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Q0FBQztJQUV0QixNQUFNLEdBQUcsR0FBRyxNQUFNLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ2hFLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsTUFBTSxJQUFJLEdBQUcsSUFBQSxtQ0FBc0IsRUFBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDckQsSUFBSSxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7UUFDcEMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1FBQ3RCLE9BQU87WUFDTCxHQUFHLEdBQUc7WUFDTixhQUFhLEVBQUUsR0FBRyxDQUFDLGFBQWEsR0FBRyxNQUFNO1lBQ3pDLFdBQVcsRUFBRSxHQUFHLENBQUMsV0FBVyxHQUFHLE1BQU07U0FDdEMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQXBDRCw4REFvQ0M7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNJLEtBQUssVUFBVSxnQkFBZ0IsQ0FDcEMsUUFBZ0IsRUFDaEIsVUFBa0I7SUFFbEIsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzlELE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFtQixDQUFDO0lBRTlDLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBWkQsNENBWUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC90cmlwbGUtc2xhc2gtcmVmZXJlbmNlXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJkb21cIiAvPlxuXG4vLyBJbnNwaXJlZCBieVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RzLXRlcnJhZm9ybS90cy10ZXJyYWZvcm1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hYXJvbnBvd2VsbC93ZWJwYWNrLWdvbGFuZy13YXNtLWFzeW5jLWxvYWRlclxuXG5pbXBvcnQgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSBcIi4vZGVlcG1lcmdlXCI7XG5pbXBvcnQgeyBndW56aXBTeW5jIH0gZnJvbSBcInpsaWJcIjtcbmltcG9ydCB7IFJlZmVyZW5jZSwgZmluZEFsbFJlZmVyZW5jZXNJbkFzdCB9IGZyb20gXCIuL3JlZmVyZW5jZXNcIjtcbmltcG9ydCB7IEV4cHJlc3Npb25UeXBlIH0gZnJvbSBcIi4vc3ludGF4LXRyZWVcIjtcbmltcG9ydCB7IHdyYXBUZXJyYWZvcm1FeHByZXNzaW9uIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5pbnRlcmZhY2UgR29CcmlkZ2Uge1xuICBwYXJzZTogKGZpbGVuYW1lOiBzdHJpbmcsIGhjbDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHBhcnNlRXhwcmVzc2lvbjogKGZpbGVuYW1lOiBzdHJpbmcsIGhjbDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIGdldEV4cHJlc3Npb25Bc3Q6IChmaWxlbmFtZTogc3RyaW5nLCBoY2w6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY29uc3QganNSb290OiBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbj4gPSB7fTtcblxuZnVuY3Rpb24gc2xlZXAoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnb0JyaWRnZShnZXRCeXRlczogUHJvbWlzZTxCdWZmZXI+KSB7XG4gIGxldCByZWFkeSA9IGZhbHNlO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgLy8gQWZ0ZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9nb2xhbmcvZ28vY29tbWl0LzY4MGNhZjE1MzU1MDU3Y2E4NDg1N2EyYTI5MWI2ZjVjNDRlNzMzMjlcbiAgICAvLyBHbyAxLjE5KyBoYXMgYSBkaWZmZXJlbnQgZW50cnlwb2ludFxuICAgIGF3YWl0IGltcG9ydChgLi4vd2FzbS9icmlkZ2Vfd2FzbV9leGVjLmpzYCk7XG4gICAgY29uc3QgZ28gPSBuZXcgKGdsb2JhbCBhcyBhbnkpLkdvKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBnZXRCeXRlcztcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgZ28uaW1wb3J0T2JqZWN0KTtcbiAgICAoZ2xvYmFsIGFzIGFueSkuX19wYXJzZV90ZXJyYWZvcm1fY29uZmlnX3dhc21fXyA9IGpzUm9vdDtcbiAgICB2b2lkIGdvLnJ1bihyZXN1bHQuaW5zdGFuY2UpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGluaXQoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG5cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30gYXMgR29CcmlkZ2UsIHtcbiAgICBnZXQ6IChfLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgcmV0dXJuIGFzeW5jICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICAgICAgd2hpbGUgKCFyZWFkeSkge1xuICAgICAgICAgIGF3YWl0IHNsZWVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShrZXkgaW4ganNSb290KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGVyZSBpcyBub3RoaW5nIGRlZmluZWQgd2l0aCB0aGUgbmFtZSBcIiR7a2V5LnRvU3RyaW5nKCl9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YganNSb290W2tleV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBqc1Jvb3Rba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2IgPSAoZXJyOiBzdHJpbmcsIC4uLm1zZzogc3RyaW5nW10pID0+XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnIgPyByZWplY3QobmV3IEVycm9yKGVycikpIDogcmVzb2x2ZSguLi5tc2cpO1xuXG4gICAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAganNSb290W2tleV0uYXBwbHkodW5kZWZpbmVkLCBbLi4uYXJncywgY2JdKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnVuKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbmNvbnN0IGxvYWRXYXNtID0gYXN5bmMgKCkgPT4ge1xuICByZXR1cm4gZ3VuemlwU3luYyhcbiAgICBhd2FpdCBmcy5yZWFkRmlsZShwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwibWFpbi53YXNtLmd6XCIpKVxuICApO1xufTtcblxuY29uc3Qgd2FzbSA9IGdvQnJpZGdlKGxvYWRXYXNtKCkpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2UoXG4gIGZpbGVuYW1lOiBzdHJpbmcsXG4gIGNvbnRlbnRzOiBzdHJpbmdcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYW55Pj4ge1xuICBjb25zdCByZXMgPSBhd2FpdCB3YXNtLnBhcnNlKGZpbGVuYW1lLCBjb250ZW50cyk7XG4gIHJldHVybiBKU09OLnBhcnNlKHJlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0RmlsZXMoXG4gIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZ1xuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG4gIGxldCB0ZkZpbGVDb250ZW50cyA9IFwiXCI7XG4gIGNvbnN0IHRmSlNPTkZpbGVDb250ZW50czogUmVjb3JkPHN0cmluZywgYW55PltdID0gW107XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZzLnJlYWRkaXJTeW5jKHdvcmtpbmdEaXJlY3RvcnkpKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUod29ya2luZ0RpcmVjdG9yeSwgZmlsZSk7XG4gICAgaWYgKCFmcy5sc3RhdFN5bmMoZmlsZVBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlmIChmaWxlLm1hdGNoKC9cXC50ZiQvKSkge1xuICAgICAgICB0ZkZpbGVDb250ZW50cyArPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgICAgIHRmRmlsZUNvbnRlbnRzICs9IFwiXFxuXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpbGUubWF0Y2goL1xcLnRmXFwuanNvbiQvKSkge1xuICAgICAgICB0ZkpTT05GaWxlQ29udGVudHMucHVzaChKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGYtOFwiKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0ZkZpbGVDb250ZW50cyA9PT0gXCJcIiAmJiB0ZkpTT05GaWxlQ29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5lcnJvcihgTm8gJy50Zicgb3IgJy50Zi5qc29uJyBmaWxlcyBmb3VuZCBpbiAke3dvcmtpbmdEaXJlY3Rvcnl9YCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmV0dXJuIGRlZXBNZXJnZShcbiAgICBhd2FpdCBwYXJzZShcImhjbDJqc29uLnRmXCIsIHRmRmlsZUNvbnRlbnRzKSxcbiAgICAuLi50ZkpTT05GaWxlQ29udGVudHNcbiAgKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIFRlcnJhZm9ybSBleHByZXNzaW9uIGFuZCByZXR1cm4gdGhlIEFTVC4gVGhpcyBmdW5jdGlvbiBleHBlY3RzIGEgc3RyaW5nIGlucHV0LCBhbmQgd2lsbCB3cmFwIHRoZSBleHByZXNzaW9uIGluIHF1b3RlcyBpZiBpdCBpcyBub3QgYWxyZWFkeSBxdW90ZWQuXG4gKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgdGhlIGV4cHJlc3Npb24uIFRoaXMgaXMgdXNlZCBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogQHBhcmFtIGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBSZWZlcmVuY2VzIGZvdW5kIGluIHRoZSBleHByZXNzaW9uLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlc0luRXhwcmVzc2lvbihcbiAgZmlsZW5hbWU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiBQcm9taXNlPFJlZmVyZW5jZVtdPiB7XG4gIC8vIFdlIGhhdmUgdG8gZG8gdGhpcyB0d2ljZSBiZWNhdXNlIG9mIHRoZSBwcm9ibGVtIHdpdGggSEVSRURPQ1NcbiAgLy8gT3VyIGN1cnJlbnQgaGNsMmpzb24gaW1wbGVtZW50YXRpb24gcmVtb3ZlcyBIRVJFRE9DUyBhbmQgcmVwbGFjZXMgdGhlbVxuICAvLyB3aXRoIGEgbXVsdGktbGluZSBzdHJpbmcsIHdoaWNoIGlzIGNhdXNpbmcgYWxsIGtpbmRzIG9mIHByb2JsZW1zXG4gIGxldCBvZmZzZXQgPSAwO1xuICBsZXQgcXVvdGVXcmFwcGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gIGlmICghZXhwcmVzc2lvbi5zdGFydHNXaXRoKCdcIicpICYmICFleHByZXNzaW9uLnN0YXJ0c1dpdGgoXCInXCIpKSB7XG4gICAgcXVvdGVXcmFwcGVkRXhwcmVzc2lvbiA9IGBcIiR7ZXhwcmVzc2lvbn1cImA7XG4gICAgb2Zmc2V0ID0gMTtcbiAgfVxuXG4gIGNvbnN0IHsgd3JhcDogd3JhcHBlZEV4cHJlc3Npb24sIHdyYXBPZmZzZXQ6IHN0YXJ0T2Zmc2V0IH0gPVxuICAgIHdyYXBUZXJyYWZvcm1FeHByZXNzaW9uKGAke3F1b3RlV3JhcHBlZEV4cHJlc3Npb259YCk7XG5cbiAgb2Zmc2V0ICs9IHN0YXJ0T2Zmc2V0O1xuXG4gIGNvbnN0IGFzdCA9IGF3YWl0IGdldEV4cHJlc3Npb25Bc3QoZmlsZW5hbWUsIHdyYXBwZWRFeHByZXNzaW9uKTtcbiAgaWYgKCFhc3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByZWZzID0gZmluZEFsbFJlZmVyZW5jZXNJbkFzdChleHByZXNzaW9uLCBhc3QpO1xuICBpZiAod3JhcHBlZEV4cHJlc3Npb24gPT09IGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gcmVmcztcbiAgfVxuXG4gIHJldHVybiByZWZzLm1hcCgocmVmKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlZixcbiAgICAgIHN0YXJ0UG9zaXRpb246IHJlZi5zdGFydFBvc2l0aW9uIC0gb2Zmc2V0LFxuICAgICAgZW5kUG9zaXRpb246IHJlZi5lbmRQb3NpdGlvbiAtIG9mZnNldCxcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIFRlcnJhZm9ybSBleHByZXNzaW9uIGFuZCByZXR1cm4gdGhlIEFTVC4gVGhlIGV4cHJlc3Npb24gZG9lcyBub3QgbmVlZCB0byBiZSBhIFRlcnJhZm9ybSBzdHJpbmcuXG4gKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgdGhlIGV4cHJlc3Npb24uIFRoaXMgaXMgdXNlZCBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogQHBhcmFtIGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgQVNUIGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqXG4gKiAgIFRoZSByZXR1cm5lZCBBU1QgaGFzIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICogICAtIHR5cGU6IFRoZSB0eXBlIG9mIHRoZSBub2RlLiBUaGlzIGlzIGEgc3RyaW5nLlxuICogICAtIHJhbmdlOiBUaGlzIGNvbnRhaW5zIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBub2RlIGluIHRoZSBleHByZXNzaW9uLlxuICogICAtIGNoaWxkcmVuOiBUaGlzIGNvbnRhaW5zIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZS4gVGhpcyBpcyBhbiBhcnJheSBvZiBub2Rlcy5cbiAqICAgLSBtZXRhOiBUaGlzIGNvbnRhaW5zIG1ldGFkYXRhIGFib3V0IHRoZSBub2RlLiBUaGlzIGlzIGFuIG9iamVjdCwgYW5kIHZhcmllcyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIG5vZGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFeHByZXNzaW9uQXN0KFxuICBmaWxlbmFtZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbik6IFByb21pc2U8RXhwcmVzc2lvblR5cGUgfCBudWxsPiB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHdhc20uZ2V0RXhwcmVzc2lvbkFzdChmaWxlbmFtZSwgZXhwcmVzc2lvbik7XG4gIGNvbnN0IGFzdCA9IEpTT04ucGFyc2UocmVzKSBhcyBFeHByZXNzaW9uVHlwZTtcblxuICBpZiAoIWFzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzdDtcbn1cbiJdfQ==