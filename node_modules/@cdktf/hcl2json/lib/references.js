"use strict";
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAllReferencesInAst = exports.traversalToReference = void 0;
const syntax_tree_1 = require("./syntax-tree");
function traversalToReference(traversalExpression, localVariables) {
    const meta = traversalExpression.meta;
    // We do not want to include property access through brackets here
    // although it is technically a traversal / reference
    function onlyTakeTraversalPartsUntilFirstBracketPropertyAccess(traversals) {
        let filtered = [];
        let index = 0;
        for (const traversal of traversals) {
            if ("segment" in traversal) {
                if (index === 0) {
                    // We are at the first traversal, check if it is a local variable
                    if (localVariables === null || localVariables === void 0 ? void 0 : localVariables.includes(traversal.segment)) {
                        // We reached a local variable, stop
                        return [];
                    }
                }
                filtered.push(traversal);
            }
            else {
                // We reached a bracket, stop
                return filtered;
            }
        }
        return filtered;
    }
    const filteredParts = onlyTakeTraversalPartsUntilFirstBracketPropertyAccess(meta.traversal);
    if (filteredParts.length === 0) {
        return null;
    }
    const startPosition = filteredParts[0].range.start.byte;
    const endPosition = filteredParts[filteredParts.length - 1].range.end.byte;
    return {
        value: filteredParts.map((part) => part.segment).join("."),
        startPosition,
        endPosition,
    };
}
exports.traversalToReference = traversalToReference;
function findAllReferencesInAst(input, entry, localVariables) {
    if (!entry) {
        return [];
    }
    switch (entry.type) {
        case "scopeTraversal":
            // For traversals within a for expression,
            // we want to ignore the local variables of the for expression
            const reference = traversalToReference(entry, localVariables);
            if (reference)
                return [reference];
            return [];
        case "for": {
            const meta = entry.meta;
            const additionalLocalVariables = [
                meta.keyVar,
                meta.valVar,
                ...(localVariables || []),
            ];
            return [
                ...findAllReferencesInAst(input, (0, syntax_tree_1.getChildWithValue)(entry, meta.collectionExpression), additionalLocalVariables),
                ...findAllReferencesInAst(input, (0, syntax_tree_1.getChildWithValue)(entry, meta.conditionalExpression), additionalLocalVariables),
            ];
        }
        default:
            return entry.children
                .map((child) => findAllReferencesInAst(input, child, localVariables))
                .flat();
    }
}
exports.findAllReferencesInAst = findAllReferencesInAst;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVmZXJlbmNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlZmVyZW5jZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7OztBQUVuQywrQ0FNdUI7QUFRdkIsU0FBZ0Isb0JBQW9CLENBQ2xDLG1CQUFrQyxFQUNsQyxjQUF5QjtJQUV6QixNQUFNLElBQUksR0FBRyxtQkFBbUIsQ0FBQyxJQUFvQyxDQUFDO0lBRXRFLGtFQUFrRTtJQUNsRSxxREFBcUQ7SUFDckQsU0FBUyxxREFBcUQsQ0FDNUQsVUFBb0M7UUFFcEMsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO1FBQ2xCLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFFO1lBQ2xDLElBQUksU0FBUyxJQUFJLFNBQVMsRUFBRTtnQkFDMUIsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO29CQUNmLGlFQUFpRTtvQkFDakUsSUFBSSxjQUFjLGFBQWQsY0FBYyx1QkFBZCxjQUFjLENBQUUsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTt3QkFDL0Msb0NBQW9DO3dCQUNwQyxPQUFPLEVBQUUsQ0FBQztxQkFDWDtpQkFDRjtnQkFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQzFCO2lCQUFNO2dCQUNMLDZCQUE2QjtnQkFDN0IsT0FBTyxRQUFRLENBQUM7YUFDakI7U0FDRjtRQUVELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRCxNQUFNLGFBQWEsR0FBRyxxREFBcUQsQ0FDekUsSUFBSSxDQUFDLFNBQVMsQ0FDZixDQUFDO0lBRUYsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0lBQ3hELE1BQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBRTNFLE9BQU87UUFDTCxLQUFLLEVBQUUsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDMUQsYUFBYTtRQUNiLFdBQVc7S0FDWixDQUFDO0FBQ0osQ0FBQztBQWpERCxvREFpREM7QUFFRCxTQUFnQixzQkFBc0IsQ0FDcEMsS0FBYSxFQUNiLEtBQXVDLEVBQ3ZDLGNBQXlCO0lBRXpCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDVixPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsUUFBUSxLQUFLLENBQUMsSUFBSSxFQUFFO1FBQ2xCLEtBQUssZ0JBQWdCO1lBQ25CLDBDQUEwQztZQUMxQyw4REFBOEQ7WUFDOUQsTUFBTSxTQUFTLEdBQUcsb0JBQW9CLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1lBQzlELElBQUksU0FBUztnQkFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDbEMsT0FBTyxFQUFFLENBQUM7UUFFWixLQUFLLEtBQUssQ0FBQyxDQUFDO1lBQ1YsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQXlCLENBQUM7WUFDN0MsTUFBTSx3QkFBd0IsR0FBRztnQkFDL0IsSUFBSSxDQUFDLE1BQU07Z0JBQ1gsSUFBSSxDQUFDLE1BQU07Z0JBQ1gsR0FBRyxDQUFDLGNBQWMsSUFBSSxFQUFFLENBQUM7YUFDMUIsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsR0FBRyxzQkFBc0IsQ0FDdkIsS0FBSyxFQUNMLElBQUEsK0JBQWlCLEVBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUNuRCx3QkFBd0IsQ0FDekI7Z0JBQ0QsR0FBRyxzQkFBc0IsQ0FDdkIsS0FBSyxFQUNMLElBQUEsK0JBQWlCLEVBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxFQUNwRCx3QkFBd0IsQ0FDekI7YUFDRixDQUFDO1NBQ0g7UUFDRDtZQUNFLE9BQU8sS0FBSyxDQUFDLFFBQVE7aUJBQ2xCLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsc0JBQXNCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztpQkFDcEUsSUFBSSxFQUFFLENBQUM7S0FDYjtBQUNILENBQUM7QUEzQ0Qsd0RBMkNDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcblxuaW1wb3J0IHtcbiAgRXhwcmVzc2lvbkFzdCxcbiAgU2NvcGVUcmF2ZXJzYWxFeHByZXNzaW9uTWV0YSxcbiAgVGVycmFmb3JtVHJhdmVyc2FsUGFydCxcbiAgRm9yRXhwcmVzc2lvbk1ldGEsXG4gIGdldENoaWxkV2l0aFZhbHVlLFxufSBmcm9tIFwiLi9zeW50YXgtdHJlZVwiO1xuXG5leHBvcnQgdHlwZSBSZWZlcmVuY2UgPSB7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIHN0YXJ0UG9zaXRpb246IG51bWJlcjtcbiAgZW5kUG9zaXRpb246IG51bWJlcjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzYWxUb1JlZmVyZW5jZShcbiAgdHJhdmVyc2FsRXhwcmVzc2lvbjogRXhwcmVzc2lvbkFzdCxcbiAgbG9jYWxWYXJpYWJsZXM/OiBzdHJpbmdbXVxuKTogUmVmZXJlbmNlIHwgbnVsbCB7XG4gIGNvbnN0IG1ldGEgPSB0cmF2ZXJzYWxFeHByZXNzaW9uLm1ldGEgYXMgU2NvcGVUcmF2ZXJzYWxFeHByZXNzaW9uTWV0YTtcblxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBpbmNsdWRlIHByb3BlcnR5IGFjY2VzcyB0aHJvdWdoIGJyYWNrZXRzIGhlcmVcbiAgLy8gYWx0aG91Z2ggaXQgaXMgdGVjaG5pY2FsbHkgYSB0cmF2ZXJzYWwgLyByZWZlcmVuY2VcbiAgZnVuY3Rpb24gb25seVRha2VUcmF2ZXJzYWxQYXJ0c1VudGlsRmlyc3RCcmFja2V0UHJvcGVydHlBY2Nlc3MoXG4gICAgdHJhdmVyc2FsczogVGVycmFmb3JtVHJhdmVyc2FsUGFydFtdXG4gICkge1xuICAgIGxldCBmaWx0ZXJlZCA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHRyYXZlcnNhbCBvZiB0cmF2ZXJzYWxzKSB7XG4gICAgICBpZiAoXCJzZWdtZW50XCIgaW4gdHJhdmVyc2FsKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIC8vIFdlIGFyZSBhdCB0aGUgZmlyc3QgdHJhdmVyc2FsLCBjaGVjayBpZiBpdCBpcyBhIGxvY2FsIHZhcmlhYmxlXG4gICAgICAgICAgaWYgKGxvY2FsVmFyaWFibGVzPy5pbmNsdWRlcyh0cmF2ZXJzYWwuc2VnbWVudCkpIHtcbiAgICAgICAgICAgIC8vIFdlIHJlYWNoZWQgYSBsb2NhbCB2YXJpYWJsZSwgc3RvcFxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZC5wdXNoKHRyYXZlcnNhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSByZWFjaGVkIGEgYnJhY2tldCwgc3RvcFxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9XG5cbiAgY29uc3QgZmlsdGVyZWRQYXJ0cyA9IG9ubHlUYWtlVHJhdmVyc2FsUGFydHNVbnRpbEZpcnN0QnJhY2tldFByb3BlcnR5QWNjZXNzKFxuICAgIG1ldGEudHJhdmVyc2FsXG4gICk7XG5cbiAgaWYgKGZpbHRlcmVkUGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzdGFydFBvc2l0aW9uID0gZmlsdGVyZWRQYXJ0c1swXS5yYW5nZS5zdGFydC5ieXRlO1xuICBjb25zdCBlbmRQb3NpdGlvbiA9IGZpbHRlcmVkUGFydHNbZmlsdGVyZWRQYXJ0cy5sZW5ndGggLSAxXS5yYW5nZS5lbmQuYnl0ZTtcblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBmaWx0ZXJlZFBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5zZWdtZW50KS5qb2luKFwiLlwiKSxcbiAgICBzdGFydFBvc2l0aW9uLFxuICAgIGVuZFBvc2l0aW9uLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEFsbFJlZmVyZW5jZXNJbkFzdChcbiAgaW5wdXQ6IHN0cmluZyxcbiAgZW50cnk6IEV4cHJlc3Npb25Bc3QgfCB1bmRlZmluZWQgfCBudWxsLFxuICBsb2NhbFZhcmlhYmxlcz86IHN0cmluZ1tdXG4pOiBSZWZlcmVuY2VbXSB7XG4gIGlmICghZW50cnkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICBjYXNlIFwic2NvcGVUcmF2ZXJzYWxcIjpcbiAgICAgIC8vIEZvciB0cmF2ZXJzYWxzIHdpdGhpbiBhIGZvciBleHByZXNzaW9uLFxuICAgICAgLy8gd2Ugd2FudCB0byBpZ25vcmUgdGhlIGxvY2FsIHZhcmlhYmxlcyBvZiB0aGUgZm9yIGV4cHJlc3Npb25cbiAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IHRyYXZlcnNhbFRvUmVmZXJlbmNlKGVudHJ5LCBsb2NhbFZhcmlhYmxlcyk7XG4gICAgICBpZiAocmVmZXJlbmNlKSByZXR1cm4gW3JlZmVyZW5jZV07XG4gICAgICByZXR1cm4gW107XG5cbiAgICBjYXNlIFwiZm9yXCI6IHtcbiAgICAgIGNvbnN0IG1ldGEgPSBlbnRyeS5tZXRhIGFzIEZvckV4cHJlc3Npb25NZXRhO1xuICAgICAgY29uc3QgYWRkaXRpb25hbExvY2FsVmFyaWFibGVzID0gW1xuICAgICAgICBtZXRhLmtleVZhcixcbiAgICAgICAgbWV0YS52YWxWYXIsXG4gICAgICAgIC4uLihsb2NhbFZhcmlhYmxlcyB8fCBbXSksXG4gICAgICBdO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5maW5kQWxsUmVmZXJlbmNlc0luQXN0KFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGdldENoaWxkV2l0aFZhbHVlKGVudHJ5LCBtZXRhLmNvbGxlY3Rpb25FeHByZXNzaW9uKSxcbiAgICAgICAgICBhZGRpdGlvbmFsTG9jYWxWYXJpYWJsZXNcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZmluZEFsbFJlZmVyZW5jZXNJbkFzdChcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBnZXRDaGlsZFdpdGhWYWx1ZShlbnRyeSwgbWV0YS5jb25kaXRpb25hbEV4cHJlc3Npb24pLFxuICAgICAgICAgIGFkZGl0aW9uYWxMb2NhbFZhcmlhYmxlc1xuICAgICAgICApLFxuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBlbnRyeS5jaGlsZHJlblxuICAgICAgICAubWFwKChjaGlsZCkgPT4gZmluZEFsbFJlZmVyZW5jZXNJbkFzdChpbnB1dCwgY2hpbGQsIGxvY2FsVmFyaWFibGVzKSlcbiAgICAgICAgLmZsYXQoKTtcbiAgfVxufVxuIl19