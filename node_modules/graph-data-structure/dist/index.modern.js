class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype)}}function t(t){const o={addNode:c,removeNode:function(n){return Object.keys(e).forEach(function(t){e[t].forEach(function(o){o===n&&d(t,o)})}),delete e[n],o},nodes:i,adjacent:u,addEdge:a,removeEdge:d,hasEdge:function(n,t){return u(n).includes(t)},setEdgeWeight:s,getEdgeWeight:h,indegree:function(n){let t=0;function o(o){o===n&&t++}return Object.keys(e).forEach(function(n){e[n].forEach(o)}),t},outdegree:function(n){return n in e?e[n].length:0},depthFirstSearch:E,hasCycle:function(){try{return E(void 0,!0,!0),!1}catch(t){if(t instanceof n)return!0;throw t}},lowestCommonAncestors:function(n,t){const o=[],e=[];return function n(r,c){return!!r[c]||(r[c]=!0,o.push(c),c==t?(e.push(c),!1):u(c).every(t=>n(r,t)))}({},n)&&function n(t,r){t[r]||(t[r]=!0,o.indexOf(r)>=0?e.push(r):0==e.length&&u(r).forEach(o=>{n(t,o)}))}({},t),e},topologicalSort:function(n,t=!0){return E(n,t,!0).reverse()},shortestPath:function(n,t){const o={},e={};let r={};function c(){let n,t=Infinity;return Object.keys(r).forEach(function(e){o[e]<t&&(t=o[e],n=e)}),void 0===n?(r={},null):(delete r[n],n)}function f(n,t){const r=h(n,t);o[t]>o[n]+r&&(o[t]=o[n]+r,e[t]=n)}return function(){for(function(){if(i().forEach(function(n){o[n]=Infinity}),Infinity!==o[n])throw new Error("Source node is not in the graph");if(Infinity!==o[t])throw new Error("Destination node is not in the graph");o[n]=0}(),i().forEach(function(n){r[n]=!0});0!==Object.keys(r).length;){const n=c();if(null===n)return;u(n).forEach(function(t){f(n,t)})}}(),function(){const o=[];let r=0,c=t;for(;e[c];)o.push(c),r+=h(e[c],c),c=e[c];if(c!==n)throw new Error("No path found");return o.push(c),o.reverse(),o.weight=r,o}()},serialize:function(){const n={nodes:i().map(function(n){return{id:n}}),links:[]};return n.nodes.forEach(function(t){const o=t.id;u(o).forEach(function(t){n.links.push({source:o,target:t,weight:h(o,t)})})}),n},deserialize:l},e={},r={};function c(n){return e[n]=u(n),o}function i(){const n={};return Object.keys(e).forEach(function(t){n[t]=!0,e[t].forEach(function(t){n[t]=!0})}),Object.keys(n)}function u(n){return e[n]||[]}function f(n,t){return n+"|"+t}function s(n,t,e){return r[f(n,t)]=e,o}function h(n,t){const o=r[f(n,t)];return void 0===o?1:o}function a(n,t,e){return c(n),c(t),u(n).push(t),void 0!==e&&s(n,t,e),o}function d(n,t){return e[n]&&(e[n]=u(n).filter(function(n){return n!==t})),o}function E(t,o=!0,e=!1){t||(t=i()),"boolean"!=typeof o&&(o=!0);const r={},c={},f=[];function s(t){if(c[t]&&e)throw new n("Cycle found");r[t]||(r[t]=!0,c[t]=!0,u(t).forEach(s),c[t]=!1,f.push(t))}return o?t.forEach(s):(t.forEach(function(n){r[n]=!0}),t.forEach(function(n){u(n).forEach(s)})),f}function l(n){return n.nodes.forEach(function(n){c(n.id)}),n.links.forEach(function(n){a(n.source,n.target,n.weight)}),o}return t&&l(t),o}export{n as CycleError,t as Graph,t as default};
//# sourceMappingURL=index.modern.js.map
