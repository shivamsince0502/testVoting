'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const zlib = require('zlib');
const fs = require('fs');
const path = require('path');
const nodeUtils = require('util');
const module$1 = require('module');
const url = require('url');
const assert = require('assert');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);

var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
  return LinkType2;
})(LinkType || {});

const prettyJsonMachine = {
  ["DEFAULT" /* DEFAULT */]: {
    collapsed: false,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["TOP_LEVEL" /* TOP_LEVEL */]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: "FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */,
      [`packageRegistryData`]: "PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */]: {
    collapsed: false,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */
    }
  },
  ["FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */
    }
  },
  ["FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */
    }
  },
  ["PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */
    }
  },
  ["PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */
    }
  },
  ["PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */
    }
  },
  ["PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: "PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */
    }
  },
  ["PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const { next } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const { collapsed } = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, "TOP_LEVEL" /* TOP_LEVEL */, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = /* @__PURE__ */ new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({ name, reference }) => name,
    ({ name, reference }) => reference
  ]);
  for (const { name, reference } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = /* @__PURE__ */ new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, { packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup }] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost. We also recommend you not to read`,
      `it either without using the @yarnpkg/pnp package, as the data layout`,
      `is entirely unspecified and WILL change from a version to another.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = zlib__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */
`,
    `"use strict";
`,
    `
`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    loader.replace(/^/gm, `  `),
    `}
`,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `return hydrateRuntimeState(JSON.parse(${generateStringLiteral(generatePrettyJson(data))}), {basePath: basePath || __dirname});
`
  ].join(``);
}
function generateSplitSetup(dataLocation) {
  return [
    `var path = require('path');
`,
    `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});
`,
    `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup(settings.dataLocation);
  const loaderFile = generateLoader(settings.shebang, setup);
  return { dataFile: generateJsonString(data), loaderFile };
}

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  rc: `.yarnrc.yml`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = () => toPortablePath(process.cwd());
ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__default.default.posix.resolve(...segments);
  } else {
    return path__default.default.posix.resolve(ppath.cwd(), ...segments);
  }
};
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b;
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
  }
  if (updated || ((_a = destinationStat == null ? void 0 : destinationStat.mtime) == null ? void 0 : _a.getTime()) !== mtime.getTime() || ((_b = destinationStat == null ? void 0 : destinationStat.atime) == null ? void 0 : _b.getTime()) !== atime.getTime()) {
    postlayout.push(() => updateTime(destination, atime, mtime));
    updated = true;
  }
  if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
    postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
    updated = true;
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
const isCloneSupportedCache = /* @__PURE__ */ new WeakMap();
function makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  return async () => {
    await opFs.linkPromise(source, destination);
    if (linkStrategy === "readOnly" /* ReadOnly */) {
      sourceStat.mode &= ~146;
      await opFs.chmodPromise(destination, sourceStat.mode);
    }
  };
}
function makeCloneLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  const isCloneSupported = isCloneSupportedCache.get(opFs);
  if (typeof isCloneSupported === `undefined`) {
    return async () => {
      try {
        await opFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE_FORCE);
        isCloneSupportedCache.set(opFs, true);
      } catch (err) {
        if (err.code === `ENOSYS` || err.code === `ENOTSUP`) {
          isCloneSupportedCache.set(opFs, false);
          await makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy)();
        } else {
          throw err;
        }
      }
    };
  } else {
    if (isCloneSupported) {
      return async () => opFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE_FORCE);
    } else {
      return makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy);
    }
  }
}
async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  var _a;
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  const linkStrategy = (_a = opts.linkStrategy) != null ? _a : null;
  const op = destinationFs === sourceFs ? linkStrategy !== null ? makeCloneLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE) : linkStrategy !== null ? makeLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
  prelayout.push(async () => op());
  return true;
}
async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

function makeError$1(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), { code });
}
function ENOSYS(message, reason) {
  return makeError$1(`ENOSYS`, `${message}, ${reason}`);
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory != null ? createdDirectory : createdDirectory = subPath;
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory != null ? createdDirectory : createdDirectory = subPath;
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}
`);
  }
  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromiseImpl(p, atime, mtime) {
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`)
      throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSyncImpl(p, atime, mtime) {
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`)
      throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts == null ? void 0 : opts.withFileTypes) {
        this.realFs.readdir(npath.fromPortablePath(p), { withFileTypes: true }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts == null ? void 0 : opts.withFileTypes) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), { withFileTypes: true });
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }
  readFileSync(p, encoding) {
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }
  async readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

function hydrateRuntimeState(data, { basePath }) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = /* @__PURE__ */ new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      var _a;
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = (_a = packageInformationData.discardFromLookup) != null ? _a : false;
      const packageLocator = { name: packageName, reference: packageReference };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, { locator: packageLocator, discardFromLookup });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert__default.default(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);
const ERR_PACKAGE_PATH_NOT_EXPORTED = createErrorType(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  (pkgPath, subpath, base = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + url.fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      url.fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = url.fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

/**
  @license
  Copyright Node.js contributors. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
*/
function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && url.fileURLToPath(new URL(".", packageJSONUrl)),
    url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${url.fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && url.fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && url.fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key)
    return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB)
    return -1;
  if (baseLenB > baseLenA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {
  if (typeof exports === "string" || ArrayIsArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys = ObjectGetOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  for (let j = 0; j < keys.length; j++) {
    const key = keys[j];
    const curIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = curIsConditionalSugar;
    } else if (isConditionalSugar !== curIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        url.fileURLToPath(packageJSONUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function throwExportsNotFound(subpath, packageJSONUrl, base) {
  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    base && url.fileURLToPath(base)
  );
}
const emittedPackageWarnings = /* @__PURE__ */ new Set();
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = url.fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${url.fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve({
  packageJSONUrl,
  packageSubpath,
  exports,
  base,
  conditions
}) {
  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))
    exports = { ".": exports };
  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath) && !StringPrototypeIncludes(packageSubpath, "*") && !StringPrototypeEndsWith(packageSubpath, "/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath;
  const keys = ObjectGetOwnPropertyNames(exports);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const patternIndex = StringPrototypeIndexOf(key, "*");
    if (patternIndex !== -1 && StringPrototypeStartsWith(
      packageSubpath,
      StringPrototypeSlice(key, 0, patternIndex)
    )) {
      if (StringPrototypeEndsWith(packageSubpath, "/"))
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJSONUrl,
          base
        );
      const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
      if (packageSubpath.length >= key.length && StringPrototypeEndsWith(packageSubpath, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = StringPrototypeSlice(
          packageSubpath,
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(
      packageJSONUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      conditions
    );
    if (resolveResult == null) {
      throwExportsNotFound(packageSubpath, packageJSONUrl, base);
    }
    return resolveResult;
  }
  throwExportsNotFound(packageSubpath, packageJSONUrl, base);
}
function packageImportsResolve({ name, base, conditions, readFileSyncFn }) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, url.fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  return ErrorCode2;
})(ErrorCode || {});
const MODULE_NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "BUILTIN_NODE_RESOLUTION_FAILED" /* BUILTIN_NODE_RESOLUTION_FAILED */,
  "MISSING_DEPENDENCY" /* MISSING_DEPENDENCY */,
  "MISSING_PEER_DEPENDENCY" /* MISSING_PEER_DEPENDENCY */,
  "QUALIFIED_PATH_RESOLUTION_FAILED" /* QUALIFIED_PATH_RESOLUTION_FAILED */,
  "UNDECLARED_DEPENDENCY" /* UNDECLARED_DEPENDENCY */
]);
function makeError(pnpCode, message, data = {}, code) {
  code != null ? code : code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: {
      ...propertySpec,
      value: code
    },
    pnpCode: {
      ...propertySpec,
      value: pnpCode
    },
    data: {
      ...propertySpec,
      value: data
    }
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const flagSymbol = Symbol('arg flag');

class ArgError extends Error {
	constructor(msg, code) {
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	}
}

function arg(
	opts,
	{
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	} = {}
) {
	if (!opts) {
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	}

	const result = { _: [] };

	const aliases = {};
	const handlers = {};

	for (const key of Object.keys(opts)) {
		if (!key) {
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		}

		if (key[0] !== '-') {
			throw new ArgError(
				`argument key must start with '-' but found: '${key}'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		}

		if (key.length === 1) {
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: ${key}`,
				'ARG_CONFIG_NONAME_KEY'
			);
		}

		if (typeof opts[key] === 'string') {
			aliases[key] = opts[key];
			continue;
		}

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) {
			const [fn] = type;
			type = (value, name, prev = []) => {
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			};
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		} else if (typeof type === 'function') {
			isFlag = type === Boolean || type[flagSymbol] === true;
		} else {
			throw new ArgError(
				`type missing or not a function or valid array type: ${key}`,
				'ARG_CONFIG_VAD_TYPE'
			);
		}

		if (key[1] !== '-' && key.length > 2) {
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: ${key}`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		}

		handlers[key] = [type, isFlag];
	}

	for (let i = 0, len = argv.length; i < len; i++) {
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) {
			result._ = result._.concat(argv.slice(i));
			break;
		}

		if (wholeArg === '--') {
			result._ = result._.concat(argv.slice(i + 1));
			break;
		}

		if (wholeArg.length > 1 && wholeArg[0] === '-') {
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-${a}`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) {
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) {
					argName = aliases[argName];
				}

				if (!(argName in handlers)) {
					if (permissive) {
						result._.push(arg);
						continue;
					} else {
						throw new ArgError(
							`unknown or unexpected option: ${originalArgName}`,
							'ARG_UNKNOWN_OPTION'
						);
					}
				}

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) {
					throw new ArgError(
						`option requires argument (but was followed by another short argument): ${originalArgName}`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				}

				if (isFlag) {
					result[argName] = type(true, argName, result[argName]);
				} else if (argStr === undefined) {
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) {
						const extended =
							originalArgName === argName ? '' : ` (alias for ${argName})`;
						throw new ArgError(
							`option requires argument: ${originalArgName}${extended}`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					}

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				} else {
					result[argName] = type(argStr, argName, result[argName]);
				}
			}
		} else {
			result._.push(wholeArg);
		}
	}

	return result;
}

arg.flag = (fn) => {
	fn[flagSymbol] = true;
	return fn;
};

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

var arg_1 = arg;

/**
  @license
  The MIT License (MIT)

  Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
function getOptionValue(opt) {
  parseOptions();
  return options[opt];
}
let options;
function parseOptions() {
  if (!options) {
    options = {
      "--conditions": [],
      ...parseArgv(getNodeOptionsEnvArgv()),
      ...parseArgv(process.execArgv)
    };
  }
}
function parseArgv(argv) {
  return arg_1(
    {
      "--conditions": [String],
      "-C": "--conditions"
    },
    {
      argv,
      permissive: true
    }
  );
}
function getNodeOptionsEnvArgv() {
  const errors = [];
  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
  if (errors.length !== 0) ;
  return envArgv;
}
function ParseNodeOptionsEnvVar(node_options, errors) {
  const env_argv = [];
  let is_in_string = false;
  let will_start_new_arg = true;
  for (let index = 0; index < node_options.length; ++index) {
    let c = node_options[index];
    if (c === "\\" && is_in_string) {
      if (index + 1 === node_options.length) {
        errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
        return env_argv;
      } else {
        c = node_options[++index];
      }
    } else if (c === " " && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c === '"') {
      is_in_string = !is_in_string;
      continue;
    }
    if (will_start_new_arg) {
      env_argv.push(c);
      will_start_new_arg = false;
    } else {
      env_argv[env_argv.length - 1] += c;
    }
  }
  if (is_in_string) {
    errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
  }
  return env_argv;
}

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;

const builtinModules = new Set(module$1.Module.builtinModules || Object.keys(process.binding(`natives`)));
const isBuiltinModule = (request) => request.startsWith(`node:`) || builtinModules.has(request);
function reportRequiredFilesToWatchMode(files) {
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    files = files.map((filename) => npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(filename))));
    if (WATCH_MODE_MESSAGE_USES_ARRAYS) {
      process.send({ "watch:require": files });
    } else {
      for (const filename of files) {
        process.send({ "watch:require": filename });
      }
    }
  }
}

function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = { name: null, reference: null };
  const fallbackLocators = [];
  const emittedWarnings = /* @__PURE__ */ new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({ name, reference });
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    var _a, _b, _c, _d, _e, _f;
    const colors = (_c = (_b = (_a = process.stderr) == null ? void 0 : _a.hasColors) == null ? void 0 : _b.call(_a)) != null ? _c : process.stdout.isTTY;
    const c = (n, str) => `\x1B[${n}m${str}\x1B[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${(_d = entry.error) == null ? void 0 : _d.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, { colors, compact: true })}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, { colors, compact: true })}`);
    }
    const stack = (_f = (_e = new Error().stack.match(/(?<=^ +)at.*/gm)) == null ? void 0 : _e.slice(2)) != null ? _f : [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(
        ErrorCode.INTERNAL,
        `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`
      );
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = /* @__PURE__ */ new Set([
    `node`,
    `require`,
    ...getOptionValue(`--conditions`)
  ]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`
      );
    }
    const { packageLocation } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    if (pkgJson.exports == null)
      return null;
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`
      );
    }
    if (subpath !== `.` && !isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    try {
      const resolvedExport = packageExportsResolve({
        packageJSONUrl: url.pathToFileURL(npath.fromPortablePath(manifestPath)),
        packageSubpath: subpath,
        exports: pkgJson.exports,
        base: issuer ? url.pathToFileURL(npath.fromPortablePath(issuer)) : null,
        conditions
      });
      return npath.toPortablePath(url.fileURLToPath(resolvedExport));
    } catch (error) {
      throw makeError(
        ErrorCode.EXPORTS_RESOLUTION_FAILED,
        error.message,
        { unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions },
        error.code
      );
    }
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions }) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, { extensions });
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({ dir: unqualifiedPath, name: `index`, ext: extensions[i] });
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, { plugnplay: false });
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = { std: 3, resolveVirtual: 1, getAllLocators: 1 };
  const topLevel = topLevelLocator;
  function getPackageInformation({ name, reference }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({ name, reference }) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = /* @__PURE__ */ new Map();
    const alreadyVisited = /* @__PURE__ */ new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = /* @__PURE__ */ new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({ name, reference });
    return brokenList;
  }
  function findPackageLocator(location, { resolveIgnored = false, includeDiscardFromLookup = false } = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function tryReadFile(filePath) {
    try {
      return opts.fakeFs.readFileSync(npath.toPortablePath(filePath), `utf8`);
    } catch (err) {
      if (err.code === `ENOENT`)
        return void 0;
      throw err;
    }
  }
  function resolveToUnqualified(request, issuer, { considerBuiltins = true } = {}) {
    if (request.startsWith(`#`))
      throw new Error(`resolveToUnqualified can not handle private import mappings`);
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && isBuiltinModule(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(
            ErrorCode.API_ERROR,
            `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(
          ErrorCode.API_ERROR,
          `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
          { request: requestForDisplay, issuer: issuerForDisplay }
        );
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(
            ErrorCode.MISSING_PEER_DEPENDENCY,
            `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
          );
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          } else {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && isBuiltinModule(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? { name: dependencyReference[0], reference: dependencyReference[1] } : { name: dependencyName, reference: dependencyReference };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(
          ErrorCode.MISSING_DEPENDENCY,
          `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
          { request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator) }
        );
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions, issuer) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions, issuer);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, { extensions = Object.keys(module$1.Module._extensions) } = {}) {
    var _a, _b;
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions });
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      reportRequiredFilesToWatchMode(candidates.map((candidate) => npath.fromPortablePath(candidate)));
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const { packageLocation } = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if ((err == null ? void 0 : err.code) === `ENOENT`) {
            exists = false;
          } else {
            const readableError = ((_b = (_a = err == null ? void 0 : err.message) != null ? _a : err) != null ? _b : `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, { unqualifiedPath: unqualifiedPathForDisplay, extensions });
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(
            ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
            `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`,
            { unqualifiedPath: unqualifiedPathForDisplay, extensions }
          );
        }
      }
      throw makeError(
        ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
        `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`,
        { unqualifiedPath: unqualifiedPathForDisplay, extensions }
      );
    }
  }
  function resolvePrivateRequest(request, issuer, opts2) {
    var _a;
    if (!issuer)
      throw new Error(`Assertion failed: An issuer is required to resolve private import mappings`);
    const resolved = packageImportsResolve({
      name: request,
      base: url.pathToFileURL(npath.fromPortablePath(issuer)),
      conditions: (_a = opts2.conditions) != null ? _a : defaultExportsConditions,
      readFileSyncFn: tryReadFile
    });
    if (resolved instanceof url.URL) {
      return resolveUnqualified(npath.toPortablePath(url.fileURLToPath(resolved)), { extensions: opts2.extensions });
    } else {
      if (resolved.startsWith(`#`))
        throw new Error(`Mapping from one private import to another isn't allowed`);
      return resolveRequest(resolved, issuer, opts2);
    }
  }
  function resolveRequest(request, issuer, opts2 = {}) {
    try {
      if (request.startsWith(`#`))
        return resolvePrivateRequest(request, issuer, opts2);
      const { considerBuiltins, extensions, conditions } = opts2;
      const unqualifiedPath = resolveToUnqualified(request, issuer, { considerBuiltins });
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !isBuiltinModule(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions, issuer) : unqualifiedPath;
      return resolveUnqualified(remappedPath, { extensions });
    } catch (error) {
      if (Object.prototype.hasOwnProperty.call(error, `pnpCode`))
        Object.assign(error.data, { request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer) });
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return { name: referencish[0], reference: referencish[1] };
      } else {
        return { name, reference: referencish };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({ name, reference });
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info, packageLocation };
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

const readFileP = nodeUtils.promisify(fs.readFile);
async function hydratePnpFile(location, { fakeFs, pnpapiResolution }) {
  const source = await readFileP(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, { basePath, fakeFs, pnpapiResolution }) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, { basePath });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, { fakeFs, pnpapiResolution });
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = zlib__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook;
};

exports.LinkType = LinkType;
exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
